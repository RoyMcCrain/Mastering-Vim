SCRIPT  /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/scripts.vim
Sourced 1 time
Total time:   0.000486
 Self time:   0.000486

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2019 Jun 25
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            "
                            " Note that the pattern matches are done with =~# to avoid the value of the
                            " 'ignorecase' option making a difference.  Where case is to be ignored use
                            " =~? instead.  Do not use =~ anywhere.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    1              0.000003 if did_filetype()
                              finish
    1              0.000001 endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    1              0.000004 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
    1              0.000001 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000005 let s:cpo_save = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000003 let s:line1 = getline(1)
                            
    1              0.000004 if s:line1 =~# "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              if s:line1 =~# '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~# '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~# '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~# '^csh\>'
                                if exists("g:filetype_csh")
                                  call dist#ft#SetFileTypeShell(g:filetype_csh)
                                else
                                  call dist#ft#SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~# '^tcsh\>'
                                call dist#ft#SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~# '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~# '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~# '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~# 'make\>'
                                set ft=make
                            
                                " Pike
                              elseif s:name =~# '^pike\%(\>\|[0-9]\)'
                                set ft=pike
                            
                                " Lua
                              elseif s:name =~# 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~# 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~# 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~# 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~# 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~# '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~# 'ruby'
                                set ft=ruby
                            
                                " JavaScript
                              elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
                                set ft=javascript
                            
                                " BC calculator
                              elseif s:name =~# '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~# 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~# 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~# 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~# 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~# 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~# 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~# 'escript'
                                set ft=erlang
                            
                                " Haskell
                              elseif s:name =~# 'haskell'
                                set ft=haskell
                            
                                " Scala
                              elseif s:name =~# 'scala\>'
                                set ft=scala
                            
                                " Clojure
                              elseif s:name =~# 'clojure'
                                set ft=clojure
                            
                              endif
                              unlet s:name
                            
    1              0.000001 else
                              " File does not start with "#!".
                            
    1              0.000002   let s:line2 = getline(2)
    1              0.000001   let s:line3 = getline(3)
    1              0.000001   let s:line4 = getline(4)
    1              0.000001   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    1              0.000003   if s:line1 =~# '^:$'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                              " Z shell scripts
    1              0.000017   elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
    1              0.000007   elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                              " Mason
    1              0.000002   elseif s:line1 =~# '^<[%&].*>'
                                set ft=mason
                            
                              " Vim scripts (must have '" vim' as the first line to trigger this)
    1              0.000002   elseif s:line1 =~# '^" *[vV]im$'
                                set ft=vim
                            
                              " libcxx and libstdc++ standard library headers like "iostream" do not have
                              " an extension, recognize the Emacs file mode.
    1              0.000003   elseif s:line1 =~? '-\*-.*C++.*-\*-'
                                set ft=cpp
                            
                              " MOO
    1              0.000005   elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
    1              0.000037   elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ')
                            	\ || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ')
                            	\ || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ')
                            	\ || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ ')))
                            	\ || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
    1              0.000003   elseif s:line1 =~# '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
    1              0.000011   elseif s:line1 =~# '^\s*dnl\>'
                            	\ || s:line2 =~# '^\s*dnl\>'
                            	\ || s:line3 =~# '^\s*dnl\>'
                            	\ || s:line4 =~# '^\s*dnl\>'
                            	\ || s:line5 =~# '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
    1              0.000003   elseif $TERM == "amiga"
                            	\ && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
    1              0.000003   elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
    1              0.000003   elseif s:line1 =~# '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
    1              0.000003   elseif s:line1 =~# '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
    1              0.000003   elseif s:line1 =~# '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                " Avoid "doctype html", used by slim.
    1              0.000003   elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
    1              0.000002   elseif s:line1 =~# '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
    1              0.000005   elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
    1              0.000006   elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
    1              0.000004   elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
    1              0.000002   elseif s:line1 =~# '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
    1              0.000002   elseif s:line1 =~# '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
    1              0.000003   elseif s:line1 =~# '^SNNS network definition file'
                                set ft=snnsnet
    1              0.000003   elseif s:line1 =~# '^SNNS pattern definition file'
                                set ft=snnspat
    1              0.000002   elseif s:line1 =~# '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
    1              0.000010   elseif s:line1 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~# '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
    1              0.000005   elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
    1              0.000004   elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
    1              0.000005   elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
                                set ft=takout
    1              0.000003   elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
    1              0.000003   elseif getline(6) =~# 'Run Date: '
                                set ft=takcmp
    1              0.000003   elseif getline(9) =~# 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
    1              0.000008   elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
    1              0.000011   elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC '
                            	\ || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
                                set ft=baan
                            
                              " Valgrind
    1              0.000005   elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Go docs
    1              0.000003   elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
                                set ft=godoc
                            
                              " Renderman Interface Bytestream
    1              0.000002   elseif s:line1 =~# '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
    1              0.000004   elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
    1              0.000008   elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
    1              0.000003    elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~# '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
    1              0.000003   elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " CVS diff
    1              0.000001   else
    1              0.000002     let s:lnum = 1
    1              0.000004     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
                                  let s:lnum += 1
    1              0.000001     endwhile
    1              0.000003     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
    1              0.000026     elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
    1              0.000001     endif
    1              0.000001     unlet s:lnum
                            
    1              0.000001   endif
                            
    1              0.000002   unlet s:line2 s:line3 s:line4 s:line5
                            
    1              0.000000 endif
                            
                            " Restore 'cpoptions'
    1              0.000006 let &cpo = s:cpo_save
                            
    1              0.000003 unlet s:cpo_save s:line1

SCRIPT  /Users/roy/.cache/dein/.cache/init.vim/.dein/autoload/denite/helper.vim
Sourced 1 time
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: helper.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000004 function! denite#helper#complete(arglead, cmdline, cursorpos) abort
                              let _ = []
                            
                              if a:arglead =~# ':'
                                " Todo: source arguments completion.
                              elseif a:arglead =~# '^-'
                                " Option names completion.
                                let bool_options = keys(filter(copy(denite#init#_user_options()),
                                      \ 'type(v:val) == type(v:true) || type(v:val) == type(v:false)'))
                                let _ += map(copy(bool_options), "'-' . tr(v:val, '_', '-')")
                                let string_options = keys(filter(copy(denite#init#_user_options()),
                                      \ 'type(v:val) != type(v:true) && type(v:val) != type(v:false)'))
                                let _ += map(copy(string_options), "'-' . tr(v:val, '_', '-') . '='")
                            
                                " Add "-no-" option names completion.
                                let _ += map(copy(bool_options), "'-no-' . tr(v:val, '_', '-')")
                              else
                                " Source name completion.
                                let _ += denite#helper#_get_available_sources()
                              endif
                            
                              return uniq(sort(filter(_, 'stridx(v:val, a:arglead) == 0')))
                            endfunction
    1              0.000002 function! denite#helper#complete_actions(arglead, cmdline, cursorpos) abort
                              return uniq(sort(filter(copy(g:denite#_actions),
                                    \ 'stridx(v:val, a:arglead) == 0')))
                            endfunction
                            
    1              0.000002 function! denite#helper#call_denite(command, args, line1, line2) abort
                              let [args, context] = denite#helper#_parse_options_args(a:args)
                            
                              let context.command = a:command
                              let context.firstline = a:line1
                              let context.lastline = a:line2
                            
                              call denite#start(args, context)
                            endfunction
                            
    1              0.000001 function! denite#helper#preview_file(context, filename) abort
                              if a:context.vertical_preview
                                let pos = win_screenpos(win_getid())
                                let win_width = winwidth(0)
                            
                                call denite#util#execute_path(
                                      \ 'silent rightbelow vertical pedit!', a:filename)
                                wincmd P
                            
                                if a:context.floating_preview && exists('*nvim_win_set_config')
                                  if a:context['split'] ==# 'floating'
                                    let win_row = str2nr(a:context['winrow'])
                                    let win_col = str2nr(a:context['wincol'])
                                  else
                                    let win_row = pos[0] - 1
                                    let win_col = pos[1] - 1
                                  endif
                                  let win_col += win_width
                                  if a:context.split !=# 'floating'
                                    let win_col -= a:context.preview_width
                                  endif
                            
                                  call nvim_win_set_config(win_getid(), {
                                       \ 'relative': 'editor',
                                       \ 'row': win_row,
                                       \ 'col': win_col,
                                       \ 'width': a:context.preview_width,
                                       \ 'height': a:context.preview_height,
                                       \ })
                                else
                                  execute 'vert resize ' . a:context.preview_width
                                endif
                              else
                                let previewheight_save = &previewheight
                                try
                                  let &previewheight = a:context.preview_height
                                  call denite#util#execute_path('silent aboveleft pedit!', a:filename)
                                finally
                                  let &previewheight = previewheight_save
                                endtry
                            
                                wincmd P
                              endif
                            
                              doautocmd User denite-preview
                            endfunction
                            
    1              0.000001 function! denite#helper#options() abort
                              return map(keys(denite#init#_user_options()), "tr(v:val, '_', '-')")
                            endfunction
                            
    1              0.000001 function! denite#helper#_parse_options_args(cmdline) abort
                              let _ = []
                              let [args, options] = s:parse_options(a:cmdline)
                            
                              for arg in args
                                " Add source name.
                                let source_name = matchstr(arg, '^[^:]*')
                                let source_arg = arg[len(source_name)+1 :]
                                let source_args = []
                                if source_arg !=# ''
                                  for s in split(source_arg, s:re_unquoted_match('\\\@<!:'), 1)
                                    call add(source_args, s:remove_quote_pairs(s))
                                  endfor
                                endif
                                call add(_, { 'name': source_name, 'args': source_args })
                              endfor
                            
                              return [_, options]
                            endfunction
    1              0.000002 function! s:re_unquoted_match(match) abort
                              " Don't match a:match if it is located in-between unescaped single or double
                              " quotes
                              return a:match . '\v\ze([^"' . "'" . '\\]*(\\.|"([^"\\]*\\.)*[^"\\]*"|'
                                    \ . "'" . '([^' . "'" . '\\]*\\.)*[^' . "'" . '\\]*' . "'" . '))*[^"'
                                    \ . "'" . ']*$'
                            endfunction
    1              0.000001 function! s:remove_quote_pairs(s) abort
                              " remove leading/ending quote pairs
                              let s = a:s
                              if s[0] ==# '"' && s[len(s) - 1] ==# '"'
                                let s = s[1: len(s) - 2]
                              elseif s[0] ==# "'" && s[len(s) - 1] ==# "'"
                                let s = s[1: len(s) - 2]
                              else
                                let s = substitute(a:s, '\\\(.\)', "\\1", 'g')
                              endif
                              return s
                            endfunction
    1              0.000001 function! s:parse_options(cmdline) abort
                              let args = []
                              let options = {}
                            
                              " Eval
                              let cmdline = (a:cmdline =~# '\\\@<!`.*\\\@<!`') ?
                                    \ s:eval_cmdline(a:cmdline) : a:cmdline
                            
                              for s in split(cmdline, s:re_unquoted_match('\%(\\\@<!\s\)\+'))
                                let arg = substitute(s, '\\\( \)', '\1', 'g')
                                let arg_key = substitute(arg, '=\zs.*$', '', '')
                            
                                let name = substitute(tr(arg_key, '-', '_'), '=$', '', '')[1:]
                                if name =~# '^no_'
                                  let name = name[3:]
                                  let value = v:false
                                else
                                  let value = (arg_key =~# '=$') ?
                                        \ s:remove_quote_pairs(arg[len(arg_key) :]) : v:true
                                endif
                            
                                if index(keys(denite#init#_user_options())
                                      \ + keys(denite#init#_deprecated_options()), name) >= 0
                                  let options[name] = value
                                else
                                  call add(args, arg)
                                endif
                              endfor
                            
                              return [args, options]
                            endfunction
    1              0.000001 function! s:eval_cmdline(cmdline) abort
                              let cmdline = ''
                              let prev_match = 0
                              let eval_pos = match(a:cmdline, '\\\@<!`.\{-}\\\@<!`')
                              while eval_pos >= 0
                                if eval_pos - prev_match > 0
                                  let cmdline .= a:cmdline[prev_match : eval_pos - 1]
                                endif
                                let prev_match = matchend(a:cmdline,
                                      \ '\\\@<!`.\{-}\\\@<!`', eval_pos)
                                let cmdline .= escape(eval(a:cmdline[eval_pos+1 : prev_match - 2]), '\ ')
                            
                                let eval_pos = match(a:cmdline, '\\\@<!`.\{-}\\\@<!`', prev_match)
                              endwhile
                              if prev_match >= 0
                                let cmdline .= a:cmdline[prev_match :]
                              endif
                            
                              return cmdline
                            endfunction
                            
    1              0.000001 function! denite#helper#has_cmdline() abort
                              if !exists('*getcompletion')
                                return 0
                              endif
                            
                              try
                                call getcompletion('', 'cmdline')
                              catch
                                return 0
                              endtry
                            
                              return 1
                            endfunction
                            
                            
    1              0.000001 function! denite#helper#_set_oldfiles(oldfiles) abort
                              let v:oldfiles = a:oldfiles
                            endfunction
    1              0.000001 function! denite#helper#_get_oldfiles() abort
                              return filter(copy(v:oldfiles),
                                    \ 'filereadable(fnamemodify(v:val, ":p")) || buflisted(v:val)')
                            endfunction
                            
                            
    1              0.000001 function! denite#helper#_get_available_sources() abort
                              if exists('s:source_names')
                                return copy(s:source_names)
                              endif
                              let s:source_names = map(
                                    \ globpath(&runtimepath, 'rplugin/python3/denite/source/**/*.py', 1, 1),
                                    \ 's:_get_source_name(v:val)',
                                    \)
                              return copy(filter(s:source_names, '!empty(v:val)'))
                            endfunction
    1              0.000001 function! denite#helper#_set_available_sources(source_names) abort
                              " Called from rplugin/python3/denite/denite.py#load_sources
                              let s:source_names = a:source_names
                            endfunction
    1              0.000001 function! s:_get_source_name(path) abort
                              let path_f = fnamemodify(a:path, ':gs?\\?/?')
                              if path_f ==# '__init__.py' || path_f ==# 'base.py'
                                return ''
                              elseif path_f[-12:] ==# '/__init__.py'
                                if getfsize(path_f) == 0
                                  " Probably the file exists for making a namespace so ignore
                                  return ''
                                endif
                                return fnamemodify(path_f, ':h:s?.*/rplugin/python3/denite/source/??:r')
                              endif
                              return fnamemodify(path_f, ':s?.*/rplugin/python3/denite/source/??:r')
                            endfunction
                            
    1              0.000001 function! denite#helper#_get_wininfo() abort
                              let wininfo = getwininfo(win_getid())[0]
                              return {
                                    \ 'bufnr': wininfo['bufnr'],
                                    \ 'winnr': wininfo['winnr'],
                                    \ 'winid': wininfo['winid'],
                                    \ 'tabnr': wininfo['tabnr'],
                                    \}
                            endfunction
    1              0.000001 function! denite#helper#_get_preview_window() abort
                              return len(filter(range(1, winnr('$')),
                                    \ "getwinvar(v:val, '&previewwindow') ==# 1"))
                            endfunction
                            
                            
    1              0.000001 function! denite#helper#_start_update_candidates_timer(bufnr) abort
                              return timer_start(100,
                                    \ {-> denite#call_async_map('update_candidates')},
                                    \ {'repeat': -1})
                            endfunction
    1              0.000001 function! denite#helper#_start_update_buffer_timer(bufnr) abort
                              return timer_start(50,
                                    \ {-> denite#_update_map('update_buffer', a:bufnr, v:false)},
                                    \ {'repeat': -1})
                            endfunction
                            
    1              0.000003 function! denite#helper#_get_temp_file(bufnr) abort
                              let temp = tempname()
                              call writefile(getbufline(a:bufnr, 1, '$'), temp)
                              return temp
                            endfunction

SCRIPT  /Users/roy/.cache/dein/.cache/init.vim/.dein/autoload/denite/init.vim
Sourced 1 time
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: init.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000004 if !exists('s:is_enabled')
    1              0.000002   let s:is_enabled = 0
    1              0.000001 endif
                            
    1              0.000002 function! denite#init#_check_channel() abort
                              return exists('g:denite#_channel_id')
                            endfunction
                            
    1              0.000001 function! denite#init#_initialize() abort
                              if denite#init#_check_channel()
                                return
                              endif
                            
                              augroup denite
                                autocmd!
                              augroup END
                            
                              if !has('python3')
                                call denite#util#print_error(
                                      \ 'denite.nvim does not work with this version.')
                                call denite#util#print_error(
                                      \ 'It requires Neovim with Python3 support("+python3").')
                                return 1
                              endif
                            
                              if has('nvim') && !has('nvim-0.3.0')
                                call denite#util#print_error('denite.nvim requires nvim +v0.3.0.')
                                return 1
                              endif
                              if !has('nvim') && v:version < 800
                                call denite#util#print_error('denite.nvim requires Vim 8.0+.')
                                return 1
                              endif
                            
                              try
                                if denite#util#has_yarp()
                                  let g:denite#_yarp = yarp#py3('denite')
                                  call g:denite#_yarp.request('_denite_init')
                                  let g:denite#_channel_id = 1
                                else
                                  " rplugin.vim may not be loaded on VimEnter
                                  if !exists('g:loaded_remote_plugins')
                                    runtime! plugin/rplugin.vim
                                  endif
                                  call _denite_init()
                                endif
                                call s:initialize_variables()
                              catch
                                call denite#util#print_error(v:exception)
                                call denite#util#print_error(v:throwpoint)
                            
                                if denite#init#_msgpack_version_check()
                                  call denite#util#print_error('denite requires msgpack 1.0.0+.')
                                endif
                            
                                if denite#util#has_yarp()
                                  if !has('nvim') && !exists('*neovim_rpc#serveraddr')
                                    call denite#util#print_error(
                                          \ 'denite requires vim-hug-neovim-rpc plugin in Vim.')
                                  endif
                            
                                  if !exists('*yarp#py3')
                                    call denite#util#print_error(
                                          \ 'denite requires nvim-yarp plugin.')
                                  endif
                                else
                                  call denite#util#print_error(
                                      \ 'denite failed to load. '
                                      \ .'Try the :UpdateRemotePlugins command and restart Neovim. '
                                      \ .'See also :checkhealth.')
                                endif
                                return 1
                              endtry
                            endfunction
    1              0.000002 function! s:initialize_variables() abort
                              let g:denite#_filter_winid = -1
                              let g:denite#_previewed_buffers = {}
                              let g:denite#_candidates = []
                              let g:denite#_ret = {}
                              let g:denite#_async_ret = {}
                              let g:denite#_filter_bufnr = -1
                              let g:denite#_serveraddr =
                                    \ denite#util#has_yarp() ?
                                    \ neovim_rpc#serveraddr() : v:servername
                              if g:denite#_serveraddr ==# ''
                                " Use NVIM_LISTEN_ADDRESS
                                let g:denite#_serveraddr = $NVIM_LISTEN_ADDRESS
                              endif
                            endfunction
                            
    1              0.000001 function! denite#init#_user_options() abort
                              return {
                                    \ 'auto_action': '',
                                    \ 'auto_resize': v:false,
                                    \ 'auto_resume': v:false,
                                    \ 'buffer_name': 'default',
                                    \ 'cursor_pos': '',
                                    \ 'cursorline': v:true,
                                    \ 'default_action': 'default',
                                    \ 'direction': 'botright',
                                    \ 'do': '',
                                    \ 'empty': v:true,
                                    \ 'expand': v:false,
                                    \ 'filter_split_direction': 'botright',
                                    \ 'filter_updatetime': 100,
                                    \ 'floating_preview': v:false,
                                    \ 'highlight_filter_background': 'NormalFloat',
                                    \ 'highlight_matched_range': 'Underlined',
                                    \ 'highlight_matched_char': 'Search',
                                    \ 'highlight_preview_line': 'Search',
                                    \ 'highlight_prompt': 'Special',
                                    \ 'highlight_window_background': 'NormalFloat',
                                    \ 'ignorecase': v:true,
                                    \ 'immediately': v:false,
                                    \ 'immediately_1': v:false,
                                    \ 'input': '',
                                    \ 'matchers': '',
                                    \ 'match_highlight': v:false,
                                    \ 'max_candidate_width': 200,
                                    \ 'max_dynamic_update_candidates': 20000,
                                    \ 'path': getcwd(),
                                    \ 'preview_height': &previewheight,
                                    \ 'preview_width': 40,
                                    \ 'prompt': '',
                                    \ 'post_action': 'none',
                                    \ 'quick_move': '',
                                    \ 'refresh': v:false,
                                    \ 'resume': v:false,
                                    \ 'reversed': v:false,
                                    \ 'root_markers': '',
                                    \ 'search': v:false,
                                    \ 'smartcase': v:false,
                                    \ 'sorters': '',
                                    \ 'split': 'horizontal',
                                    \ 'source_names': '',
                                    \ 'start_filter': v:false,
                                    \ 'statusline': v:true,
                                    \ 'unique': v:false,
                                    \ 'vertical_preview': v:false,
                                    \ 'wincol': &columns / 4,
                                    \ 'winheight': 20,
                                    \ 'winrow': &lines / 2 - 10,
                                    \ 'winwidth': &columns / 2,
                                    \ 'winminheight': -1,
                                    \}
                            endfunction
    1              0.000001 function! denite#init#_deprecated_options() abort
                              return {}
                            endfunction
                            
    1              0.000001 function! denite#init#_python_version_check() abort
                              python3 << EOF
                            import vim
                            import sys
                            vim.vars['denite#_python_version_check'] = (
                                sys.version_info.major,
                                sys.version_info.minor,
                                sys.version_info.micro) < (3, 6, 1)
                            EOF
                              return g:denite#_python_version_check
                            endfunction
                            
    1              0.000001 function! denite#init#_msgpack_version_check() abort
                              python3 << EOF
                            import vim
                            import msgpack
                            vim.vars['denite#_msgpack_version_check'] = msgpack.version < (1, 0, 0)
                            EOF
                              return get(g:, 'denite#_msgpack_version_check', 0)
                            endfunction

SCRIPT  /Users/roy/.cache/dein/.cache/init.vim/.dein/autoload/denite.vim
Sourced 1 time
Total time:   0.000096
 Self time:   0.000096

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: denite.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000002 function! denite#initialize() abort
                              return denite#init#_initialize()
                            endfunction
    1              0.000001 function! denite#start(sources, ...) abort
                              call inputsave()
                              try
                                let user_context = get(a:000, 0, {})
                                return s:start(a:sources, user_context)
                              finally
                                call inputrestore()
                              endtry
                            endfunction
                            
                            " Statusline functions
    1              0.000001 function! denite#get_status(name) abort
                              return !exists('b:denite_statusline') ? '' :
                                    \ get(b:denite_statusline, a:name, '')
                            endfunction
                            
    1              0.000002 function! s:start(sources, user_context) abort
                              if denite#initialize()
                                return
                              endif
                            
                              " Add current position to the jumplist.
                              let pos = getpos('.')
                              execute line('.')
                              call setpos('.', pos)
                            
                              let args = [a:sources, a:user_context]
                              return denite#util#rpcrequest('_denite_start', args, v:false)
                            endfunction
                            
    1              0.000002 function! denite#do_action(context, action_name, targets) abort
                              let args = [a:context, a:action_name, a:targets]
                              return denite#util#rpcrequest('_denite_do_action', args, v:false)
                            endfunction
                            
    1              0.000001 function! denite#do_map(name, ...) abort
                              let args = denite#util#convert2list(get(a:000, 0, []))
                              let esc = (mode() ==# 'i' ? "\<C-o>" : '')
                              return printf(esc . ":\<C-u>call denite#_call_map(%s, %s, %s)\<CR>",
                                    \ string(a:name), 'v:false', string(args))
                            endfunction
    1              0.000002 function! denite#_call_map(name, is_async, args) abort
                              let is_filter = &l:filetype ==# 'denite-filter'
                            
                              if is_filter
                                call denite#filter#_move_to_parent(v:true)
                              endif
                            
                              if &l:filetype !=# 'denite'
                                return
                              endif
                            
                              let args = denite#util#convert2list(a:args)
                            
                              call denite#util#rpcrequest(
                                    \ (a:is_async ? '_denite_do_async_map' : '_denite_do_map'),
                                    \ [bufnr('%'), a:name, args], a:is_async)
                            
                              if is_filter
                                call s:update_filter()
                              endif
                            endfunction
    1              0.000002 function! denite#_update_map(name, bufnr, is_async) abort
                              let is_filter = &l:filetype ==# 'denite-filter'
                            
                              call denite#util#rpcrequest(
                                    \ (a:is_async ? '_denite_do_async_map' : '_denite_do_map'),
                                    \ [a:bufnr, a:name, []], a:is_async)
                            
                              if is_filter
                                call s:update_filter()
                              endif
                            endfunction
    1              0.000001 function! s:update_filter() abort
                              let denite_statusline = getbufvar(g:denite#_filter_parent,
                                    \ 'denite_statusline', {})
                            
                              if win_getid() != g:denite#_filter_winid
                                noautocmd call win_gotoid(g:denite#_filter_winid)
                              endif
                            
                              if &l:filetype ==# 'denite-filter'
                                resize 1
                                let b:denite_statusline = denite_statusline
                              else
                                stopinsert
                              endif
                            endfunction
    1              0.000001 function! denite#call_map(name, ...) abort
                              call denite#_call_map(a:name, v:false, get(a:000, 0, []))
                            endfunction
    1              0.000001 function! denite#call_async_map(name, ...) abort
                              call denite#_call_map(a:name, v:true, get(a:000, 0, []))
                            endfunction

SCRIPT  /Users/roy/.cache/dein/.cache/init.vim/.dein/autoload/denite/filter.vim
Sourced 1 time
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: filter.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000004 function! denite#filter#_open(context, parent, entire_len, is_async) abort
                              let denite_statusline = get(b:, 'denite_statusline', {})
                            
                              let id = win_findbuf(g:denite#_filter_bufnr)
                              if !empty(id)
                                call win_gotoid(id[0])
                                call cursor(line('$'), 0)
                              else
                                call s:new_filter_buffer(a:context)
                              endif
                            
                              let g:denite#_filter_parent = a:parent
                              let g:denite#_filter_context = a:context
                              let g:denite#_filter_entire_len = a:entire_len
                            
                              call s:init_buffer()
                            
                              let b:denite_statusline = denite_statusline
                            
                              " Set the current input
                              if getline('$') ==# ''
                                call setline('$', a:context['input'])
                              else
                                call append('$', a:context['input'])
                              endif
                            
                              if a:context['prompt'] !=# '' && strwidth(a:context['prompt']) <= 2
                                call s:init_prompt(a:context)
                              endif
                            
                              augroup denite-filter
                                autocmd!
                                autocmd InsertEnter <buffer> call s:start_timer()
                                autocmd InsertLeave <buffer> call s:stop_timer()
                                autocmd InsertLeave <buffer> call s:update()
                              augroup END
                            
                              call cursor(line('$'), 0)
                              startinsert!
                            
                              let g:denite#_filter_prev_input = getline('.')
                            endfunction
                            
    1              0.000002 function! s:init_buffer() abort
                              setlocal bufhidden=hide
                              setlocal buftype=nofile
                              setlocal colorcolumn=
                              setlocal foldcolumn=0
                              setlocal nobuflisted
                              setlocal nofoldenable
                              setlocal nolist
                              setlocal nomodeline
                              setlocal nonumber
                              setlocal norelativenumber
                              setlocal nospell
                              setlocal noswapfile
                              setlocal nowrap
                              setlocal signcolumn=auto
                              setlocal winfixheight
                            
                              resize 1
                            
                              nnoremap <buffer><silent> <Plug>(denite_filter_update)
                                    \ :<C-u>call <SID>async_update()<CR>
                              inoremap <buffer><silent> <Plug>(denite_filter_update)
                                    \ <ESC>:call <SID>async_update()<CR>
                              nnoremap <buffer><silent> <Plug>(denite_filter_quit)
                                    \ :<C-u>call <SID>quit(v:true)<CR>
                              inoremap <buffer><silent> <Plug>(denite_filter_quit)
                                    \ <ESC>:<C-u>call <SID>quit(v:true)<CR>
                              inoremap <buffer><silent><expr> <Plug>(denite_filter_backspace)
                                    \ col('.') == 1 ? "a\<BS>" : "\<BS>"
                            
                              nmap <buffer> <CR> <Plug>(denite_filter_update)
                              nmap <buffer> q    <Plug>(denite_filter_quit)
                            
                              imap <buffer> <CR> <Plug>(denite_filter_update)
                              imap <buffer> <BS> <Plug>(denite_filter_backspace)
                              imap <buffer> <C-h> <Plug>(denite_filter_backspace)
                            
                              setfiletype denite-filter
                            endfunction
                            
    1              0.000002 function! s:new_filter_buffer(context) abort
                              if denite#util#check_floating(a:context)
                                let row = win_screenpos(win_getid())[0] - 1
                                " Note: win_screenpos() == [1, 1] if start_filter
                                if row <= 0
                                  let row = a:context['filter_winrow']
                                  let on_start_filter = v:true
                                else
                                  let on_start_filter = v:false
                                endif
                                let winrow = str2nr(a:context['winrow'])
                                let wincol = str2nr(a:context['wincol'])
                                if a:context['split'] ==# 'floating'
                                  call nvim_open_win(bufnr('%'), v:true, {
                                        \ 'relative': 'editor',
                                        \ 'row': winrow == 1 ? 0 : row + winheight(0),
                                        \ 'col': wincol,
                                        \ 'width': str2nr(a:context['winwidth']),
                                        \ 'height': 1,
                                        \})
                                elseif a:context['split'] ==# 'floating_relative'
                                  " cursor position cannot be gotten from this function.
                                  " so instead estimating it from floating buffer position.
                                    call nvim_open_win(bufnr('%'), v:true, {
                                        \ 'relative': 'editor',
                                        \ 'row': on_start_filter ? row : row + winheight(0),
                                        \ 'col': on_start_filter ? nvim_win_get_config(0)['col']
                                          \ : win_screenpos(0)[1] - 1,
                                        \ 'width': winwidth(0),
                                        \ 'height': 1,
                                        \})
                                elseif a:context['filter_split_direction'] ==# 'floating'
                                  call nvim_open_win(bufnr('%'), v:true, {
                                        \ 'relative': 'editor',
                                        \ 'row': row + winheight(0) + 1,
                                        \ 'col': win_screenpos(0)[1] - 1,
                                        \ 'width': winwidth(0),
                                        \ 'height': 1,
                                        \})
                                endif
                                if exists('*bufadd')
                                  let bufnr = bufadd('denite-filter')
                                  execute bufnr 'buffer'
                                else
                                  silent edit denite-filter
                                endif
                                let &l:winhighlight = 'Normal:' . a:context['highlight_filter_background']
                              else
                                silent execute a:context['filter_split_direction'] 'split' 'denite-filter'
                              endif
                            
                              let g:denite#_filter_winid = win_getid()
                              let g:denite#_filter_bufnr = bufnr('%')
                            endfunction
                            
    1              0.000001 function! s:init_prompt(context) abort
                              let name = 'denite_filter_prompt'
                              let id = 2000
                              if exists('*sign_define')
                                call sign_define(name, {
                                      \ 'text': a:context['prompt'],
                                      \ 'texthl': a:context['highlight_prompt']
                                      \ })
                                call sign_unplace('', {'id': id, 'buffer': bufnr('%')})
                                call sign_place(id, '', name, bufnr('%'), {'lnum': line('$')})
                              else
                                execute printf('sign define %s text=%s texthl=%s',
                                      \ name, a:context['prompt'], a:context['highlight_prompt'])
                                execute printf('silent! sign unplace %d buffer=%s',
                                      \ id, bufnr('%'))
                                execute printf('sign place %d name=%s line=%d buffer=%d',
                                      \ id, name, line('$'), bufnr('%'))
                              endif
                            endfunction
                            
    1              0.000001 function! s:filter_async() abort
                              let input = getline('.')
                            
                              if &filetype !=# 'denite-filter'
                                    \ || input ==# g:denite#_filter_prev_input
                                return
                              endif
                            
                              let g:denite#_filter_prev_input = input
                            
                              call denite#util#rpcrequest('_denite_do_async_map',
                                    \ [g:denite#_filter_parent, 'filter_async', [input]], v:true)
                            endfunction
                            
    1              0.000001 function! s:update() abort
                              if &filetype !=# 'denite-filter'
                                return
                              endif
                            
                              call denite#call_map('filter', getline('.'))
                            endfunction
                            
    1              0.000001 function! s:async_update() abort
                              if &filetype !=# 'denite-filter'
                                return
                              endif
                            
                              let input = getline('.')
                            
                              call s:quit(v:false)
                            
                              call denite#call_async_map('filter', input)
                            endfunction
                            
    1              0.000001 function! s:quit(force_quit) abort
                              if a:force_quit
                                call s:update()
                              endif
                            
                              let context = g:denite#_filter_context
                            
                              if winnr('$') ==# 1
                                buffer #
                              elseif a:force_quit || !context['start_filter']
                                close!
                              endif
                            
                              call denite#filter#_move_to_parent(v:false)
                            
                              call s:stop_timer()
                            
                              if win_id2win(g:denite#_filter_winid) <= 0
                                let g:denite#_filter_winid = -1
                              endif
                            endfunction
                            
    1              0.000001 function! denite#filter#_move_to_parent(is_async) abort
                              let id = win_findbuf(g:denite#_filter_parent)
                              if empty(id)
                                return
                              endif
                            
                              if a:is_async
                                " Note: noautocmd for statusline flicker
                                noautocmd call win_gotoid(id[0])
                              else
                                call win_gotoid(id[0])
                              endif
                            endfunction
    1              0.000001 function! denite#filter#_close_filter_window() abort
                              if !exists('g:denite#_filter_winid')
                                    \ || g:denite#_filter_winid < 0
                                    \ || win_id2win(g:denite#_filter_winid) <= 0
                                return
                              endif
                            
                              let prev = win_getid()
                            
                              call win_gotoid(g:denite#_filter_winid)
                              close!
                            
                              call win_gotoid(prev)
                            endfunction
                            
    1              0.000001 function! s:start_timer() abort
                              if exists('g:denite#_filter_candidates_timer')
                                return
                              endif
                            
                              let context = g:denite#_filter_context
                              if g:denite#_filter_entire_len <
                                    \ context['max_dynamic_update_candidates'] &&
                                    \ context['filter_updatetime'] > 0
                                let g:denite#_filter_candidates_timer = timer_start(
                                      \ context['filter_updatetime'],
                                      \ {-> s:filter_async()}, {'repeat': -1})
                              endif
                            endfunction
    1              0.000001 function! s:stop_timer() abort
                              if !exists('g:denite#_filter_candidates_timer')
                                return
                              endif
                            
                              call timer_stop(g:denite#_filter_candidates_timer)
                              unlet g:denite#_filter_candidates_timer
                            endfunction

SCRIPT  /Users/roy/.cache/dein/.cache/init.vim/.dein/autoload/lsp/ui/vim.vim
Sourced 1 time
Total time:   0.000326
 Self time:   0.000326

count  total (s)   self (s)
    1              0.000006 function! s:not_supported(what) abort
                                return lsp#utils#error(a:what.' not supported for '.&filetype)
                            endfunction
                            
    1              0.000002 function! lsp#ui#vim#implementation(in_preview) abort
                                let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_implementation_provider(v:val)')
                                let l:command_id = lsp#_new_command()
                                call setqflist([])
                            
                                if len(l:servers) == 0
                                    call s:not_supported('Retrieving implementation')
                                    return
                                endif
                                let l:ctx = { 'counter': len(l:servers), 'list':[], 'last_command_id': l:command_id, 'jump_if_one': 1, 'in_preview': a:in_preview }
                                for l:server in l:servers
                                    call lsp#send_request(l:server, {
                                        \ 'method': 'textDocument/implementation',
                                        \ 'params': {
                                        \   'textDocument': lsp#get_text_document_identifier(),
                                        \   'position': lsp#get_position(),
                                        \ },
                                        \ 'on_notification': function('s:handle_location', [l:ctx, l:server, 'implementation']),
                                        \ })
                                endfor
                            
                                echo 'Retrieving implementation ...'
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#type_definition(in_preview) abort
                                let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_type_definition_provider(v:val)')
                                let l:command_id = lsp#_new_command()
                                call setqflist([])
                            
                                if len(l:servers) == 0
                                    call s:not_supported('Retrieving type definition')
                                    return
                                endif
                                let l:ctx = { 'counter': len(l:servers), 'list':[], 'last_command_id': l:command_id, 'jump_if_one': 1, 'in_preview': a:in_preview }
                                for l:server in l:servers
                                    call lsp#send_request(l:server, {
                                        \ 'method': 'textDocument/typeDefinition',
                                        \ 'params': {
                                        \   'textDocument': lsp#get_text_document_identifier(),
                                        \   'position': lsp#get_position(),
                                        \ },
                                        \ 'on_notification': function('s:handle_location', [l:ctx, l:server, 'type definition']),
                                        \ })
                                endfor
                            
                                echo 'Retrieving type definition ...'
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#type_hierarchy() abort
                                let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_type_hierarchy_provider(v:val)')
                                let l:command_id = lsp#_new_command()
                            
                                if len(l:servers) == 0
                                    call s:not_supported('Retrieving type hierarchy')
                                    return
                                endif
                                let l:ctx = { 'counter': len(l:servers), 'list':[], 'last_command_id': l:command_id }
                                " direction 0 children, 1 parent, 2 both
                                for l:server in l:servers
                                    call lsp#send_request(l:server, {
                                        \ 'method': 'textDocument/typeHierarchy',
                                        \ 'params': {
                                        \   'textDocument': lsp#get_text_document_identifier(),
                                        \   'position': lsp#get_position(),
                                        \   'direction': 2,
                                        \   'resolve': 1,
                                        \ },
                                        \ 'on_notification': function('s:handle_type_hierarchy', [l:ctx, l:server, 'type hierarchy']),
                                        \ })
                                endfor
                            
                                echo 'Retrieving type hierarchy ...'
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#declaration(in_preview) abort
                                let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_declaration_provider(v:val)')
                                let l:command_id = lsp#_new_command()
                                call setqflist([])
                            
                                if len(l:servers) == 0
                                    call s:not_supported('Retrieving declaration')
                                    return
                                endif
                            
                                let l:ctx = { 'counter': len(l:servers), 'list':[], 'last_command_id': l:command_id, 'jump_if_one': 1, 'in_preview': a:in_preview }
                                for l:server in l:servers
                                    call lsp#send_request(l:server, {
                                        \ 'method': 'textDocument/declaration',
                                        \ 'params': {
                                        \   'textDocument': lsp#get_text_document_identifier(),
                                        \   'position': lsp#get_position(),
                                        \ },
                                        \ 'on_notification': function('s:handle_location', [l:ctx, l:server, 'declaration']),
                                        \ })
                                endfor
                            
                                echo 'Retrieving declaration ...'
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#definition(in_preview) abort
                                let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_definition_provider(v:val)')
                                let l:command_id = lsp#_new_command()
                                call setqflist([])
                            
                                if len(l:servers) == 0
                                    call s:not_supported('Retrieving definition')
                                    return
                                endif
                            
                                let l:ctx = { 'counter': len(l:servers), 'list':[], 'last_command_id': l:command_id, 'jump_if_one': 1, 'in_preview': a:in_preview }
                                for l:server in l:servers
                                    call lsp#send_request(l:server, {
                                        \ 'method': 'textDocument/definition',
                                        \ 'params': {
                                        \   'textDocument': lsp#get_text_document_identifier(),
                                        \   'position': lsp#get_position(),
                                        \ },
                                        \ 'on_notification': function('s:handle_location', [l:ctx, l:server, 'definition']),
                                        \ })
                                endfor
                            
                                echo 'Retrieving definition ...'
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#references() abort
                                let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_references_provider(v:val)')
                                let l:command_id = lsp#_new_command()
                            
                                call setqflist([])
                            
                                let l:ctx = { 'counter': len(l:servers), 'list':[], 'last_command_id': l:command_id, 'jump_if_one': 0, 'in_preview': 0 }
                                if len(l:servers) == 0
                                    call s:not_supported('Retrieving references')
                                    return
                                endif
                            
                                for l:server in l:servers
                                    call lsp#send_request(l:server, {
                                        \ 'method': 'textDocument/references',
                                        \ 'params': {
                                        \   'textDocument': lsp#get_text_document_identifier(),
                                        \   'position': lsp#get_position(),
                                        \   'context': {'includeDeclaration': v:false},
                                        \ },
                                        \ 'on_notification': function('s:handle_location', [l:ctx, l:server, 'references']),
                                        \ })
                                endfor
                            
                                echo 'Retrieving references ...'
                            endfunction
                            
    1              0.000002 function! s:rename(server, new_name, pos) abort
                                if empty(a:new_name)
                                    echo '... Renaming aborted ...'
                                    return
                                endif
                            
                                " needs to flush existing open buffers
                                call lsp#send_request(a:server, {
                                    \ 'method': 'textDocument/rename',
                                    \ 'params': {
                                    \   'textDocument': lsp#get_text_document_identifier(),
                                    \   'position': a:pos,
                                    \   'newName': a:new_name,
                                    \ },
                                    \ 'on_notification': function('s:handle_workspace_edit', [a:server, lsp#_last_command(), 'rename']),
                                    \ })
                            
                                echo ' ... Renaming ...'
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#rename() abort
                                let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_rename_prepare_provider(v:val)')
                                let l:prepare_support = 1
                                if len(l:servers) == 0
                                    let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_rename_provider(v:val)')
                                    let l:prepare_support = 0
                                endif
                            
                                let l:command_id = lsp#_new_command()
                            
                                if len(l:servers) == 0
                                    call s:not_supported('Renaming')
                                    return
                                endif
                            
                                " TODO: ask the user which server it should use to rename if there are multiple
                                let l:server = l:servers[0]
                            
                                if l:prepare_support
                                    call lsp#send_request(l:server, {
                                        \ 'method': 'textDocument/prepareRename',
                                        \ 'params': {
                                        \   'textDocument': lsp#get_text_document_identifier(),
                                        \   'position': lsp#get_position(),
                                        \ },
                                        \ 'on_notification': function('s:handle_rename_prepare', [l:server, l:command_id, 'rename_prepare']),
                                        \ })
                                    return
                                endif
                            
                                call s:rename(l:server, input('new name: ', expand('<cword>')), lsp#get_position())
                            endfunction
                            
    1              0.000001 function! s:document_format(sync) abort
                                let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_document_formatting_provider(v:val)')
                                let l:command_id = lsp#_new_command()
                            
                                if len(l:servers) == 0
                                    call s:not_supported('Document formatting')
                                    return
                                endif
                            
                                " TODO: ask user to select server for formatting
                                let l:server = l:servers[0]
                                redraw | echo 'Formatting document ...'
                                call lsp#send_request(l:server, {
                                    \ 'method': 'textDocument/formatting',
                                    \ 'params': {
                                    \   'textDocument': lsp#get_text_document_identifier(),
                                    \   'options': {
                                    \       'tabSize': getbufvar(bufnr('%'), '&tabstop'),
                                    \       'insertSpaces': getbufvar(bufnr('%'), '&expandtab') ? v:true : v:false,
                                    \   },
                                    \ },
                                    \ 'sync': a:sync,
                                    \ 'on_notification': function('s:handle_text_edit', [l:server, l:command_id, 'document format']),
                                    \ })
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#document_format_sync() abort
                                let l:mode = mode()
                                if l:mode =~# '[vV]' || l:mode ==# "\<C-V>"
                                    return s:document_format_range(1)
                                endif
                                return s:document_format(1)
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#document_format() abort
                                let l:mode = mode()
                                if l:mode =~# '[vV]' || l:mode ==# "\<C-V>"
                                    return s:document_format_range(0)
                                endif
                                return s:document_format(0)
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#stop_server(...) abort
                                let l:name = get(a:000, 0, '')
                                for l:server in lsp#get_whitelisted_servers()
                                    if !empty(l:name) && l:server != l:name
                                        continue
                                    endif
                                    echo 'Stopping' l:server 'server ...'
                                    call lsp#stop_server(l:server)
                                endfor
                            endfunction
                            
    1              0.000001 function! s:get_selection_pos(type) abort
                                if a:type ==? 'v'
                                    let l:start_pos = getpos("'<")[1:2]
                                    let l:end_pos = getpos("'>")[1:2]
                                    " fix end_pos column (see :h getpos() and :h 'selection')
                                    let l:end_line = getline(l:end_pos[0])
                                    let l:offset = (&selection ==# 'inclusive' ? 1 : 2)
                                    let l:end_pos[1] = len(l:end_line[:l:end_pos[1]-l:offset])
                                    " edge case: single character selected with selection=exclusive
                                    if l:start_pos[0] == l:end_pos[0] && l:start_pos[1] > l:end_pos[1]
                                        let l:end_pos[1] = l:start_pos[1]
                                    endif
                                elseif a:type ==? 'line'
                                    let l:start_pos = [line("'["), 1]
                                    let l:end_lnum = line("']")
                                    let l:end_pos = [line("']"), len(getline(l:end_lnum))]
                                elseif a:type ==? 'char'
                                    let l:start_pos = getpos("'[")[1:2]
                                    let l:end_pos = getpos("']")[1:2]
                                else
                                    let l:start_pos = [0, 0]
                                    let l:end_pos = [0, 0]
                                endif
                            
                                return l:start_pos + l:end_pos
                            endfunction
                            
    1              0.000001 function! s:document_format_range(sync, type) abort
                                let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_document_range_formatting_provider(v:val)')
                                let l:command_id = lsp#_new_command()
                            
                                if len(l:servers) == 0
                                    call s:not_supported('Document range formatting')
                                    return
                                endif
                            
                                " TODO: ask user to select server for formatting
                                let l:server = l:servers[0]
                            
                                let [l:start_lnum, l:start_col, l:end_lnum, l:end_col] = s:get_selection_pos(a:type)
                                let l:start_char = lsp#utils#to_char('%', l:start_lnum, l:start_col)
                                let l:end_char = lsp#utils#to_char('%', l:end_lnum, l:end_col)
                                redraw | echo 'Formatting document range ...'
                                call lsp#send_request(l:server, {
                                    \ 'method': 'textDocument/rangeFormatting',
                                    \ 'params': {
                                    \   'textDocument': lsp#get_text_document_identifier(),
                                    \   'range': {
                                    \       'start': { 'line': l:start_lnum - 1, 'character': l:start_char },
                                    \       'end': { 'line': l:end_lnum - 1, 'character': l:end_char },
                                    \   },
                                    \   'options': {
                                    \       'tabSize': getbufvar(bufnr('%'), '&shiftwidth'),
                                    \       'insertSpaces': getbufvar(bufnr('%'), '&expandtab') ? v:true : v:false,
                                    \   },
                                    \ },
                                    \ 'sync': a:sync,
                                    \ 'on_notification': function('s:handle_text_edit', [l:server, l:command_id, 'range format']),
                                    \ })
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#document_range_format_sync() abort
                                return s:document_format_range(1, visualmode())
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#document_range_format() abort
                                return s:document_format_range(0, visualmode())
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#document_range_format_opfunc(type) abort
                                return s:document_format_range(1, a:type)
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#workspace_symbol() abort
                                let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_workspace_symbol_provider(v:val)')
                                let l:command_id = lsp#_new_command()
                            
                                call setqflist([])
                            
                                if len(l:servers) == 0
                                    call s:not_supported('Retrieving workspace symbols')
                                    return
                                endif
                            
                                let l:query = inputdialog('query>', '', "\<ESC>")
                                if l:query ==# "\<ESC>"
                                    return
                                endif
                            
                                for l:server in l:servers
                                    call lsp#send_request(l:server, {
                                        \ 'method': 'workspace/symbol',
                                        \ 'params': {
                                        \   'query': l:query,
                                        \ },
                                        \ 'on_notification': function('s:handle_symbol', [l:server, l:command_id, 'workspaceSymbol']),
                                        \ })
                                endfor
                            
                                redraw
                                echo 'Retrieving workspace symbols ...'
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#document_symbol() abort
                                let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_document_symbol_provider(v:val)')
                                let l:command_id = lsp#_new_command()
                            
                                call setqflist([])
                            
                                if len(l:servers) == 0
                                    call s:not_supported('Retrieving symbols')
                                    return
                                endif
                            
                                for l:server in l:servers
                                    call lsp#send_request(l:server, {
                                        \ 'method': 'textDocument/documentSymbol',
                                        \ 'params': {
                                        \   'textDocument': lsp#get_text_document_identifier(),
                                        \ },
                                        \ 'on_notification': function('s:handle_symbol', [l:server, l:command_id, 'documentSymbol']),
                                        \ })
                                endfor
                            
                                echo 'Retrieving document symbols ...'
                            endfunction
                            
    1              0.000002 function! s:handle_symbol(server, last_command_id, type, data) abort
                                if a:last_command_id != lsp#_last_command()
                                    return
                                endif
                            
                                if lsp#client#is_error(a:data['response'])
                                    call lsp#utils#error('Failed to retrieve '. a:type . ' for ' . a:server . ': ' . lsp#client#error_message(a:data['response']))
                                    return
                                endif
                            
                                let l:list = lsp#ui#vim#utils#symbols_to_loc_list(a:server, a:data)
                            
                                call setqflist(l:list)
                            
                                if empty(l:list)
                                    call lsp#utils#error('No ' . a:type .' found')
                                else
                                    echo 'Retrieved ' . a:type
                                    botright copen
                                endif
                            endfunction
                            
    1              0.000002 function! s:handle_location(ctx, server, type, data) abort "ctx = {counter, list, jump_if_one, last_command_id, in_preview}
                                if a:ctx['last_command_id'] != lsp#_last_command()
                                    return
                                endif
                            
                                let a:ctx['counter'] = a:ctx['counter'] - 1
                            
                                if lsp#client#is_error(a:data['response']) || !has_key(a:data['response'], 'result')
                                    call lsp#utils#error('Failed to retrieve '. a:type . ' for ' . a:server . ': ' . lsp#client#error_message(a:data['response']))
                                else
                                    let a:ctx['list'] = a:ctx['list'] + lsp#utils#location#_lsp_to_vim_list(a:data['response']['result'])
                                endif
                            
                                if a:ctx['counter'] == 0
                                    if empty(a:ctx['list'])
                                        call lsp#utils#error('No ' . a:type .' found')
                                    else
                                        call lsp#utils#tagstack#_update()
                            
                                        let l:loc = a:ctx['list'][0]
                            
                                        if len(a:ctx['list']) == 1 && a:ctx['jump_if_one'] && !a:ctx['in_preview']
                                            call lsp#utils#location#_open_vim_list_item(l:loc)
                                            echo 'Retrieved ' . a:type
                                            redraw
                                        elseif !a:ctx['in_preview']
                                            call setqflist(a:ctx['list'])
                                            echo 'Retrieved ' . a:type
                                            botright copen
                                        else
                                            let l:lines = readfile(fnameescape(l:loc['filename']))
                                            if has_key(l:loc,'viewstart') " showing a locationLink
                                                let l:view = l:lines[l:loc['viewstart'] : l:loc['viewend']]
                                                call lsp#ui#vim#output#preview(a:server, l:view, {
                                                    \   'statusline': ' LSP Peek ' . a:type,
                                                    \   'filetype': &filetype
                                                    \ })
                                            else " showing a location
                                                call lsp#ui#vim#output#preview(a:server, l:lines, {
                                                    \   'statusline': ' LSP Peek ' . a:type,
                                                    \   'cursor': { 'line': l:loc['lnum'], 'col': l:loc['col'], 'align': g:lsp_peek_alignment },
                                                    \   'filetype': &filetype
                                                    \ })
                                            endif
                                        endif
                                    endif
                                endif
                            endfunction
                            
    1              0.000002 function! s:handle_rename_prepare(server, last_command_id, type, data) abort
                                if a:last_command_id != lsp#_last_command()
                                    return
                                endif
                            
                                if lsp#client#is_error(a:data['response'])
                                    call lsp#utils#error('Failed to retrieve '. a:type . ' for ' . a:server . ': ' . lsp#client#error_message(a:data['response']))
                                    return
                                endif
                            
                                let l:range = a:data['response']['result']
                                let l:lines = getline(1, '$')
                                let [l:start_line, l:start_col] = lsp#utils#position#lsp_to_vim('%', l:range['start'])
                                let [l:end_line, l:end_col] = lsp#utils#position#lsp_to_vim('%', l:range['end'])
                                if l:start_line ==# l:end_line
                                    let l:name = l:lines[l:start_line - 1][l:start_col - 1 : l:end_col - 2]
                                else
                                    let l:name = l:lines[l:start_line - 1][l:start_col - 1 :]
                                    for l:i in range(l:start_line, l:end_line - 2)
                                        let l:name .= "\n" . l:lines[l:i]
                                    endfor
                                    if l:end_col - 2 < 0
                                        let l:name .= "\n"
                                    else
                                        let l:name .= l:lines[l:end_line - 1][: l:end_col - 2]
                                    endif
                                endif
                            
                                call timer_start(1, {x->s:rename(a:server, input('new name: ', l:name), l:range['start'])})
                            endfunction
                            
    1              0.000002 function! s:handle_workspace_edit(server, last_command_id, type, data) abort
                                if a:last_command_id != lsp#_last_command()
                                    return
                                endif
                            
                                if lsp#client#is_error(a:data['response'])
                                    call lsp#utils#error('Failed to retrieve '. a:type . ' for ' . a:server . ': ' . lsp#client#error_message(a:data['response']))
                                    return
                                endif
                            
                                call lsp#utils#workspace_edit#apply_workspace_edit(a:data['response']['result'])
                            
                                echo 'Renamed'
                            endfunction
                            
    1              0.000001 function! s:handle_text_edit(server, last_command_id, type, data) abort
                                if a:last_command_id != lsp#_last_command()
                                    return
                                endif
                            
                                if lsp#client#is_error(a:data['response'])
                                    call lsp#utils#error('Failed to '. a:type . ' for ' . a:server . ': ' . lsp#client#error_message(a:data['response']))
                                    return
                                endif
                            
                                call lsp#utils#text_edit#apply_text_edits(a:data['request']['params']['textDocument']['uri'], a:data['response']['result'])
                            
                                redraw | echo 'Document formatted'
                            endfunction
                            
    1              0.000002 function! s:handle_type_hierarchy(ctx, server, type, data) abort "ctx = {counter, list, last_command_id}
                                if a:ctx['last_command_id'] != lsp#_last_command()
                                    return
                                endif
                            
                                if lsp#client#is_error(a:data['response'])
                                    call lsp#utils#error('Failed to '. a:type . ' for ' . a:server . ': ' . lsp#client#error_message(a:data['response']))
                                    return
                                endif
                            
                                if empty(a:data['response']['result'])
                                    echo 'No type hierarchy found'
                                    return
                                endif
                            
                                " Create new buffer in a split
                                let l:position = 'topleft'
                                let l:orientation = 'new'
                                exec l:position . ' ' . 10 . l:orientation
                            
                                let l:provider = {
                                    \   'root': a:data['response']['result'],
                                    \   'root_state': 'expanded',
                                    \   'bufnr': bufnr('%'),
                                    \   'getChildren': function('s:get_children_for_tree_hierarchy'),
                                    \   'getParent': function('s:get_parent_for_tree_hierarchy'),
                                    \   'getTreeItem': function('s:get_treeitem_for_tree_hierarchy'),
                                    \ }
                            
                                call lsp#utils#tree#new(l:provider)
                            
                                echo 'Retrieved type hierarchy'
                            endfunction
                            
    1              0.000001 function! s:hierarchyitem_to_treeitem(hierarchyitem) abort
                                return {
                                    \ 'id': a:hierarchyitem,
                                    \ 'label': a:hierarchyitem['name'],
                                    \ 'command': function('s:hierarchy_treeitem_command', [a:hierarchyitem]),
                                    \ 'collapsibleState': has_key(a:hierarchyitem, 'parents') && !empty(a:hierarchyitem['parents']) ? 'expanded' : 'none',
                                    \ }
                            endfunction
                            
    1              0.000001 function! s:hierarchy_treeitem_command(hierarchyitem) abort
                                bwipeout
                                call lsp#utils#tagstack#_update()
                                call lsp#utils#location#_open_lsp_location(a:hierarchyitem)
                            endfunction
                            
    1              0.000001 function! s:get_children_for_tree_hierarchy(Callback, ...) dict abort
                                if a:0 == 0
                                    call a:Callback('success', [l:self['root']])
                                    return
                                else
                                    call a:Callback('success', a:1['parents'])
                                endif
                            endfunction
                            
    1              0.000001 function! s:get_parent_for_tree_hierarchy(...) dict abort
                                " TODO
                            endfunction
                            
    1              0.000001 function! s:get_treeitem_for_tree_hierarchy(Callback, object) dict abort
                                call a:Callback('success', s:hierarchyitem_to_treeitem(a:object))
                            endfunction
                            
    1              0.000001 function! lsp#ui#vim#code_action() abort
                                call lsp#ui#vim#code_action#do({
                                    \   'sync': v:false,
                                    \   'selection': v:false,
                                    \   'query': '',
                                    \ })
                            endfunction

SCRIPT  /Users/roy/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier.vim
Sourced 1 time
Total time:   0.000881
 Self time:   0.000881

count  total (s)   self (s)
                            " vim-prettier: A vim plugin wrapper for prettier, pre-configured with custom default prettier settings.
                            "
                            " Script Info  {{{
                            "==========================================================================================================
                            " Name Of File: prettier.vim
                            "  Description: A vim plugin wrapper for prettier, pre-configured with custom default prettier settings.
                            "   Maintainer: Mitermayer Reis <mitermayer.reis at gmail.com>
                            "      Version: 1.0.0-alpha
                            "        Usage: Use :help vim-prettier-usage, or visit https://github.com/prettier/vim-prettier
                            "
                            "==========================================================================================================
                            " }}}
                            
                            " Displays the resolve prettier CLI path
    1              0.000003 function! prettier#PrettierCliPath() abort
                              let l:execCmd = prettier#resolver#executable#getPath()
                            
                              if l:execCmd != -1
                                echom l:execCmd
                              else
                                call prettier#logging#error#log('EXECUTABLE_NOT_FOUND_ERROR')
                              endif
                            endfunction
                            
                            " Allows user commands to be passed straight to the prettier CLI
    1              0.000002 function! prettier#PrettierCli(user_input) abort
                              let l:execCmd = prettier#resolver#executable#getPath()
                            
                              if l:execCmd != -1
                                let l:out = system(l:execCmd. ' ' . a:user_input)
                                echom l:out
                              else
                                call prettier#logging#error#log('EXECUTABLE_NOT_FOUND_ERROR')
                              endif
                            endfunction
                            
                            " Allows @format and @prettier pragma support upon saving
    1              0.000001 function! prettier#Autoformat(...) abort
                              let l:autoformat = g:prettier#autoformat_config_present ?
                                    \ prettier#IsConfigPresent(g:prettier#autoformat_config_files) :
                                    \ g:prettier#autoformat
                            
                              if l:autoformat
                                call prettier#Prettier(1, 1, line('$'), 0, {
                                  \ 'requirePragma': g:prettier#autoformat_require_pragma ? 'true' : 'false'
                                  \ })
                              endif
                            endfunction
                            
                            " Main prettier command
    1              0.000001 function! prettier#Prettier(...) abort
                              let l:execCmd = prettier#resolver#executable#getPath()
                              let l:async = a:0 > 0 ? a:1 : 0
                              let l:startSelection = a:0 > 1 ? a:2 : 1
                              let l:endSelection = a:0 > 2 ? a:3 : line('$')
                              let l:hasSelection = a:0 > 2 ? 1 : 0
                              let l:partialFormat = a:0 > 3 && a:4 ? a:4 : 0
                              let l:partialFormatEnabled = l:hasSelection && l:partialFormat
                            
                              let l:overWrite = a:0 > 4 ? a:5 : {}
                              let l:bufferConfig = getbufvar(bufnr('%'), 'prettier_ft_default_args', {})
                              let l:config = extend(l:bufferConfig, l:overWrite)
                            
                              if l:execCmd != -1
                                " TODO
                                " => we should make sure we can resolve --range-start  and --range-end when required
                                "    => when the above is required we should also update l:startSelection to '1' and l:endSelection to line('$')
                                let l:cmd = l:execCmd . prettier#resolver#config#resolve(
                                      \ prettier#resolver#preset#resolve(l:config),
                                      \ l:partialFormatEnabled,
                                      \ l:startSelection, 
                                      \ l:endSelection)
                            
                                " close quickfix if it is opened
                                call prettier#utils#quickfix#close()
                            
                                " we will be using portion formatting, so we need to send entire buffer to prettier
                                if l:partialFormatEnabled
                                  let l:startSelection = 1
                                  let l:endSelection = line('$')
                                endif
                            
                                " format buffer
                                call prettier#job#runner#run(l:cmd, l:startSelection, l:endSelection, l:async)
                              else
                                call prettier#logging#error#log('EXECUTABLE_NOT_FOUND_ERROR')
                              endif
                            endfunction
                            
                            " Set autoformat toggle based on whether config file was found.
    1              0.000001 function! prettier#IsConfigPresent(config_files) abort
                              for config_file in a:config_files
                                if filereadable(findfile(config_file, '.;'))
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction

SCRIPT  /Users/roy/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/executable.vim
Sourced 1 time
Total time:   0.000514
 Self time:   0.000514

count  total (s)   self (s)
    1              0.000053 let s:ROOT_DIR = fnamemodify(resolve(expand('<sfile>:p')), ':h')
                            
                            " By default we will search for the following
                            " => user defined prettier cli path from vim configuration file
                            " => locally installed prettier inside node_modules on any parent folder
                            " => globally installed prettier
                            " => vim-prettier prettier installation
                            " => if all fails suggest install
    1              0.000002 function! prettier#resolver#executable#getPath() abort
                              let l:user_defined_exec_path = fnamemodify(g:prettier#exec_cmd_path, ':p')
                              if executable(l:user_defined_exec_path)
                                return l:user_defined_exec_path
                              endif
                            
                              let l:localExec = s:ResolveExecutable(getcwd())
                              if executable(l:localExec)
                                return fnameescape(l:localExec)
                              endif
                            
                              let l:globalExec = s:ResolveExecutable()
                              if executable(l:globalExec)
                                return fnameescape(l:globalExec)
                              endif
                            
                              let l:pluginExec = s:ResolveExecutable(s:ROOT_DIR)
                              if executable(l:pluginExec)
                                return fnameescape(l:pluginExec)
                              endif
                            
                              return -1
                            endfunction
                            
    1              0.000002 function! s:GetExecPath(...) abort
                              let l:rootDir = a:0 > 0 ? a:1 : -1
                              let l:dir = l:rootDir != -1 ? l:rootDir . '/.bin/' : ''
                              return l:dir . 'prettier'
                            endfunction
                            
                            " Searches for the existence of a directory accross 
                            " ancestral parents
    1              0.000002 function! s:TraverseAncestorDirSearch(rootDir) abort
                              let l:root = a:rootDir
                              let l:dir = 'node_modules'
                            
                              while 1
                                let l:searchDir = l:root . '/' . l:dir
                                if isdirectory(l:searchDir)
                                  return l:searchDir
                                endif
                            
                                let l:parent = fnamemodify(l:root, ':h')
                                if l:parent == l:root
                                  return -1
                                endif
                            
                                let l:root = l:parent
                              endwhile
                            endfunction
                            
    1              0.000001 function! s:ResolveExecutable(...) abort
                              let l:rootDir = a:0 > 0 ? a:1 : 0
                              let l:exec = -1
                            
                              if isdirectory(l:rootDir)
                                let l:dir = s:TraverseAncestorDirSearch(l:rootDir)
                                if l:dir != -1
                                  let l:exec = s:GetExecPath(l:dir)
                                endif
                              else
                                let l:exec = s:GetExecPath()
                              endif
                            
                              return l:exec
                            endfunction

SCRIPT  /Users/roy/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/preset.vim
Sourced 1 time
Total time:   0.000241
 Self time:   0.000241

count  total (s)   self (s)
                            " Build config using predefined preset 
    1              0.000003 function! prettier#resolver#preset#resolve(fileTypeConfigOverwrites) abort
                              if ( g:prettier#preset#config ==# 'fb' )
                                return extend(prettier#presets#fb#config(), a:fileTypeConfigOverwrites)
                              endif
                            
                              return a:fileTypeConfigOverwrites
                            endfunction

SCRIPT  /Users/roy/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/config.vim
Sourced 1 time
Total time:   0.000294
 Self time:   0.000294

count  total (s)   self (s)
                            " By default we will default to our internal
                            " configuration settings for prettier
    1              0.000005 function! prettier#resolver#config#resolve(config, hasSelection, start, end) abort
                              " Allow params to be passed as json format
                              " convert bellow usage of globals to a get function o the params defaulting to global
                              " TODO: Use a list, filter() and join() to get a nicer list of args.
                              let l:cmd = s:Flag_use_tabs(a:config) . ' ' .
                                      \ s:Flag_tab_width(a:config) . ' ' .
                                      \ s:Flag_print_width(a:config) . ' ' .
                                      \ s:Flag_parser(a:config) . ' ' .
                                      \ s:Flag_range_delimiter(a:config, a:hasSelection, a:start, a:end) . ' ' .
                                      \ ' --semi=' .
                                      \ get(a:config, 'semi', g:prettier#config#semi) .
                                      \ ' --single-quote=' .
                                      \ get(a:config, 'singleQuote', g:prettier#config#single_quote) .
                                      \ ' --bracket-spacing=' .
                                      \ get(a:config, 'bracketSpacing', g:prettier#config#bracket_spacing) .
                                      \ ' --jsx-bracket-same-line=' .
                                      \ get(a:config, 'jsxBracketSameLine', g:prettier#config#jsx_bracket_same_line) .
                                      \ ' --arrow-parens=' .
                                      \ get(a:config, 'arrowParens', g:prettier#config#arrow_parens) .
                                      \ ' --trailing-comma=' .
                                      \ get(a:config, 'trailingComma', g:prettier#config#trailing_comma) .
                                      \ ' --config-precedence=' .
                                      \ get(a:config, 'configPrecedence', g:prettier#config#config_precedence) .
                                      \ ' --prose-wrap=' .
                                      \ get(a:config, 'proseWrap', g:prettier#config#prose_wrap) .
                                      \ ' --html-whitespace-sensitivity ' .
                                      \ get(a:config, 'htmlWhitespaceSensitivity', g:prettier#config#html_whitespace_sensitivity) .
                                      \ ' --stdin-filepath="'.simplify(expand('%:p')).'"' .
                                      \ ' --require-pragma=' .
                                      \ get(a:config, 'requirePragma', g:prettier#config#require_pragma) .
                                      \ ' --loglevel error '.
                                      \ ' --stdin '
                              return l:cmd
                            endfunction
                            
                            " Returns either '--range-start X --range-end Y' or an empty string.
    1              0.000003 function! s:Flag_range_delimiter(config, partialFormatEnabled, start, end) abort
                              if (!a:partialFormatEnabled)
                                return ''
                              endif
                            
                              let l:range = prettier#utils#buffer#getCharRange(a:start, a:end)
                            
                              return '--range-start=' . l:range[0] . ' --range-end=' . l:range[1]
                            endfunction
                            
                            " Returns '--tab-width=NN'
    1              0.000001 function! s:Flag_tab_width(config) abort
                              let l:value = get(a:config, 'tabWidth', g:prettier#config#tab_width)
                            
                              if (l:value ==# 'auto')
                                let l:value = prettier#utils#shim#shiftwidth()
                              endif
                            
                              return '--tab-width=' . l:value
                            endfunction
                            
                            " Returns either '--use-tabs' or an empty string.
    1              0.000001 function! s:Flag_use_tabs(config) abort
                              let l:value = get(a:config, 'useTabs', g:prettier#config#use_tabs)
                              if (l:value ==# 'auto')
                                let l:value = &expandtab ? 'false' : 'true'
                              endif
                            
                              if ( l:value ==# 'true' )
                                return ' --use-tabs'
                              else
                                return ''
                              endif
                            endfunction
                            
                            " Returns '--print-width=NN' or ''
    1              0.000001 function! s:Flag_print_width(config) abort
                              let l:value = get(a:config, 'printWidth', g:prettier#config#print_width)
                            
                              if (l:value ==# 'auto')
                                let l:value = &textwidth
                              endif
                            
                              if (l:value > 0)
                                return '--print-width=' . l:value
                              else
                                return ''
                              endif
                            endfunction
                            
                            " Returns '--parser=PARSER' or ''
    1              0.000001 function! s:Flag_parser(config) abort
                              let l:value = get(a:config, 'parser', g:prettier#config#parser)
                            
                              if (l:value !=# '')
                                return '--parser=' . l:value
                              else
                                return ''
                              endif
                            endfunction

SCRIPT  /Users/roy/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/utils/shim.vim
Sourced 1 time
Total time:   0.000329
 Self time:   0.000329

count  total (s)   self (s)
                            " Backwards compatable version of shiftwidth()
    1              0.000003 function! prettier#utils#shim#shiftwidth() abort
                              if exists('*shiftwidth')
                                return shiftwidth()
                              else
                                return &shiftwidth
                              endif
                            endfunction

SCRIPT  /Users/roy/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/utils/quickfix.vim
Sourced 1 time
Total time:   0.000287
 Self time:   0.000287

count  total (s)   self (s)
                            " We use this flag so that we ensure only clearing quickfix if it was created by prettier itself
    1              0.000004 let s:prettier_quickfix_open = 0
                            
    1              0.000002 function! prettier#utils#quickfix#close() abort
                              " close quickfix if it is opened
                              if s:prettier_quickfix_open
                                call setqflist([], 'r')
                                cclose
                                let s:prettier_quickfix_open = 0
                              endif
                            endfunction
                            
    1              0.000002 function! prettier#utils#quickfix#open(errors, focus) abort
                              let s:prettier_quickfix_open = 1
                              let l:winnr = winnr()
                              call setqflist(a:errors, 'r')
                              botright copen
                              if !a:focus
                                " Return the cursor back to the main buffer.
                                exe l:winnr . 'wincmd w'
                              endif
                            endfunction

SCRIPT  /Users/roy/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/job/runner.vim
Sourced 1 time
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
                            " TODO
                            " move the bellow vim checks to UTILS
    1              0.000005 let s:isLegacyVim = v:version < 800
    1              0.000004 let s:isNeoVim = has('nvim')
    1              0.000003 let s:isAsyncVim = !s:isLegacyVim && exists('*job_start')
                            
    1              0.000003 function! prettier#job#runner#run(cmd, startSelection, endSelection, async) abort
                                if a:async && (s:isAsyncVim || s:isNeoVim)
                                  call s:asyncFormat(a:cmd, a:startSelection, a:endSelection)
                                else
                                  call s:format(a:cmd, a:startSelection, a:endSelection)
                                endif
                            endfunction
                            
    1              0.000001 function! prettier#job#runner#onError(errors) abort
                              call prettier#logging#error#log('PARSING_ERROR')
                              if g:prettier#quickfix_enabled
                                call prettier#bridge#parser#onError(a:errors, g:prettier#quickfix_auto_focus)
                              endif
                            endfunction
                            
    1              0.000002 function! s:asyncFormat(cmd, startSelection, endSelection) abort
                                if !s:isAsyncVim && !s:isNeoVim 
                                  call s:format(a:cmd, a:startSelection, a:endSelection)
                                endif 
                            
                                " required for Windows support on async operations 
                                let l:cmd = a:cmd
                                if has('win32') || has('win64')
                                  let l:cmd = 'cmd.exe /c ' . a:cmd
                                endif
                            
                                if s:isAsyncVim
                                  call prettier#job#async#vim#run(l:cmd, a:startSelection, a:endSelection)
                                else
                                  call prettier#job#async#neovim#run(l:cmd, a:startSelection, a:endSelection)
                                endif
                            endfunction
                            
    1              0.000001 function! s:format(cmd, startSelection, endSelection) abort
                              let l:bufferLinesList = getbufline(bufnr('%'), a:startSelection, a:endSelection)
                            
                              " vim 7 does not have support for passing a list to system()
                              let l:bufferLines = s:isLegacyVim ? join(l:bufferLinesList, "\n") : l:bufferLinesList
                            
                              " TODO
                              " since we are using two different types for system, maybe we should move it to utils shims
                              let l:out = split(system(a:cmd, l:bufferLines), '\n')
                            
                              " check system exit code
                              if v:shell_error
                                call prettier#job#runner#onError(l:out)
                                return
                              endif
                            
                              " TODO
                              " doing 0 checks seems weird can we do this bellow differently ?
                              if (prettier#utils#buffer#willUpdatedLinesChangeBuffer(l:out, a:startSelection, a:endSelection) == 0)
                                return
                              endif
                            
                              call prettier#utils#buffer#replace(l:out, a:startSelection, a:endSelection)
                            endfunction

SCRIPT  /Users/roy/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/job/async/neovim.vim
Sourced 1 time
Total time:   0.000311
 Self time:   0.000311

count  total (s)   self (s)
    1              0.000005 let s:prettier_job_running = 0
                            
    1              0.000003 function! prettier#job#async#neovim#run(cmd, startSelection, endSelection) abort
                              if s:prettier_job_running == 1
                                return
                              endif
                              let s:prettier_job_running = 1
                            
                              let l:lines = getline(a:startSelection, a:endSelection)
                              let l:dict = {
                                    \ 'start': a:startSelection - 1,
                                    \ 'end': a:endSelection,
                                    \ 'buf_nr': bufnr('%'),
                                    \ 'content': l:lines,
                                    \}
                              let l:out = []
                              let l:err = []
                            
                              let l:job = jobstart([&shell, &shellcmdflag, a:cmd], {
                                \ 'stdout_buffered': 1,
                                \ 'stderr_buffered': 1,
                                \ 'on_stdout': {job_id, data, event -> extend(l:out, data)},
                                \ 'on_stderr': {job_id, data, event -> extend(l:err, data)},
                                \ 'on_exit': {job_id, status, event -> s:onExit(status, l:dict, l:out, l:err)},
                                \ })
                              call jobsend(l:job, l:lines)
                              call jobclose(l:job, 'stdin')
                            endfunction
                            
                            " todo
                            " Lets refactor this onExit to work similar to our solution for vim8
                            " at the moment an info json object is been passed with some cached data
                            " that is than used to do the formatting, its not following the same convetion
                            " as the vim8 one and is error prone
                            "
                            " we should:
                            "
                            " 1. make it similar to the vim8 approach
                            " 2. extract common functionality either above to the runner or to some other module
                            "
                            " to test this it rellies on using nvim and having the flag 
                            "
                            "  note that somehow we exectuing both async and sync on nvim when using the autoformat
    1              0.000003 function! s:onExit(status, info, out, err) abort
                              let l:currentBufferNumber =  bufnr('%')
                              let l:isInsideAnotherBuffer = a:info.buf_nr != l:currentBufferNumber ? 1 : 0
                              let l:last = a:out[len(a:out) - 1]
                              let l:out = l:last ==? '' ? a:out[0:len(a:out) - 2] : a:out
                            
                              " parsing errors
                              if a:status != 0
                                call prettier#job#runner#onError(a:err)
                                let s:prettier_job_running = 0
                                return
                              endif
                            
                              " we have no prettier output so lets exit
                              if len(l:out) == 0 | return | endif
                            
                              " nothing to update
                              if (prettier#utils#buffer#willUpdatedLinesChangeBuffer(l:out, a:info.start, a:info.end) == 0)
                                let s:prettier_job_running = 0
                                redraw!
                                return
                              endif
                            
                              " This is required due to race condition when user quickly switch buffers while the async
                              " cli has not finished running, vim 8.0.1039 has introduced setbufline() which can be used
                              " to fix this issue in a cleaner way, however since we still need to support older vim versions
                              " we will apply a more generic solution
                              if (l:isInsideAnotherBuffer)
                                " Do no try to format buffers that have been closed
                                if (bufloaded(a:info.buf_nr))
                                  try
                                    silent exec 'sp '. escape(bufname(a:info.buf_nr), ' \')
                                    call prettier#utils#buffer#replaceAndSave(l:out, a:info.start, a:info.end)
                                  catch
                                    call prettier#logging#error#log('PARSING_ERROR')
                                  finally
                                    " we should then hide this buffer again
                                    if a:info.buf_nr == bufnr('%')
                                      silent hide
                                    endif
                                  endtry
                                endif
                              else 
                                call prettier#utils#buffer#replaceAndSave(l:out, a:info.start, a:info.end)
                              endif
                              let s:prettier_job_running = 0
                            endfunction

FUNCTION  FugitiveExtractGitDir()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/fugitive.vim:215
Called 1 time
Total time:   0.000294
 Self time:   0.000180

count  total (s)   self (s)
    1   0.000011   0.000006   let path = s:Slash(a:path)
    1              0.000003   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
    1              0.000001   elseif empty(path)
                                return ''
    1              0.000006   elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
    1              0.000000   else
    1              0.000010     let path = fnamemodify(path, ':p:h:s?/$??')
    1              0.000000   endif
    1              0.000008   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    1              0.000002   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
    1              0.000000   endif
    1              0.000025   let root = resolve(path)
    1              0.000001   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
    1              0.000000   endif
    1              0.000001   let previous = ""
    1              0.000007   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
    1   0.000015   0.000007   call s:Tree(env_git_dir)
    1              0.000002   while root !=# previous
    1              0.000005     if root =~# '\v^//%([^/]+/?)?$'
                                  break
    1              0.000000     endif
    1   0.000026   0.000007     if index(s:CeilingDirectories(), root) >= 0
                                  break
    1              0.000000     endif
    1              0.000003     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
    1              0.000002     elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
    1              0.000000     endif
    1              0.000040     let dir = substitute(root, '[\/]$', '', '') . '/.git'
    1              0.000012     let type = getftype(dir)
    1   0.000091   0.000008     if type ==# 'dir' && FugitiveIsGitDir(dir)
    1              0.000001       return dir
                                elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
                                elseif FugitiveIsGitDir(root)
                                  return root
                                endif
                                let previous = root
                                let root = fnamemodify(root, ':h')
                              endwhile
                              return ''

FUNCTION  neomru#append()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:334
Called 7 times
Total time:   0.090640
 Self time:   0.001522

count  total (s)   self (s)
    7   0.000237   0.000059   let path = s:fnamemodify(a:filename, ':p')
    7              0.000147   if path !~ '\a\+:'
    7   0.000213   0.000170     let path = s:substitute_path_separator( simplify(s:resolve(path)))
    7              0.000006   endif
                            
                              " Append the current buffer to the mru list.
    7   0.000613   0.000052   if s:is_file_exist(path)
    5   0.087548   0.000070     call s:file_mru.append(path)
    7              0.000005   endif
                            
    7              0.000518   let filetype = getbufvar(bufnr(a:filename), '&filetype')
    7              0.000033   if filetype ==# 'vimfiler' && type(getbufvar(bufnr(a:filename), 'vimfiler')) == type({})
                                let path = getbufvar(bufnr(a:filename), 'vimfiler').current_dir
    7              0.000020   elseif filetype ==# 'vimshell' && type(getbufvar(bufnr(a:filename), 'vimshell')) == type({})
                                let path = getbufvar(bufnr(a:filename), 'vimshell').current_dir
    7              0.000003   else
    7   0.000274   0.000065     let path = s:fnamemodify(path, ':p:h')
    7              0.000003   endif
                            
    7   0.000166   0.000126   let path = s:substitute_path_separator(simplify(s:resolve(path)))
                              " Chomp last /.
    7              0.000046   let path = substitute(path, '/$', '', '')
                            
                              " Append the current buffer to the mru list.
    7   0.000408   0.000049   if s:is_directory_exist(path)
    7   0.000321   0.000070     call s:directory_mru.append(path)
    7              0.000004   endif

FUNCTION  deoplete#custom#_get()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/custom.vim:60
Called 4 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    4              0.000013   if !exists('s:custom')
                                call deoplete#custom#_init()
    4              0.000002   endif
                            
    4              0.000003   return s:custom

FUNCTION  <SNR>80_get_nest()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:643
Called 38 times
Total time:   0.008934
 Self time:   0.000960

count  total (s)   self (s)
   38   0.004577   0.000595   let context = s:get_context(a:filetype, a:context_filetypes, s:file_range())
   38   0.004338   0.000347   return s:get_nest_impl(context.filetype, a:context_filetypes, context)

FUNCTION  <SNR>27_after_ftplugin()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/ftplugin.vim:30
Called 3 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  <SNR>80_file_range()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:500
Called 38 times
Total time:   0.000220
 Self time:   0.000220

count  total (s)   self (s)
   38              0.000206   return [[1, 1], [line('$'), len(getline('$'))+1]]

FUNCTION  indent_guides#enable()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:33
Called 11 times
Total time:   0.027380
 Self time:   0.013551

count  total (s)   self (s)
   11              0.000018   let g:indent_guides_autocmds_enabled = 1
                            
   11   0.000268   0.000084   if &diff || indent_guides#exclude_filetype()
                                call indent_guides#clear_matches()
                                return
   11              0.000004   end
                            
   11   0.001178   0.000074   call indent_guides#init_script_vars()
   11   0.003924   0.000086   call indent_guides#highlight_colors()
   11   0.003842   0.000094   call indent_guides#clear_matches()
                            
                              " loop through each indent level and define a highlight pattern
                              " will automagically figure out whether to use tabs or spaces
  330              0.000294   for l:level in range(s:start_level, s:indent_levels)
  319              0.000620     let l:group = 'IndentGuides' . ((l:level % 2 == 0) ? 'Even' : 'Odd')
  319              0.000441     let l:column_start = (l:level - 1) * s:indent_size + 1
                            
                                " define the higlight patterns and add to matches list
  319              0.000256     if g:indent_guides_space_guides
  319   0.005254   0.002823       let l:soft_pattern = indent_guides#indent_highlight_pattern(g:indent_guides_soft_pattern, l:column_start, s:guide_size)
  319              0.002343       call add(w:indent_guides_matches, matchadd(l:group, l:soft_pattern))
  319              0.000160     end
  319              0.000250     if g:indent_guides_tab_guides
  319   0.005408   0.002884       let l:hard_pattern = indent_guides#indent_highlight_pattern('\t', l:column_start, s:indent_size)
  319              0.002295       call add(w:indent_guides_matches, matchadd(l:group, l:hard_pattern))
  319              0.000136     end
  330              0.000138   endfor

FUNCTION  <SNR>13_vimoption2python()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/util.vim:54
Called 4 times
Total time:   0.000795
 Self time:   0.000553

count  total (s)   self (s)
    4              0.000005   let has_dash = 0
    4              0.000003   let patterns = []
   20              0.000037   for pattern in split(a:option, ',')
   16              0.000043     if pattern =~# '\d\+'
    8              0.000070       let pattern = substitute(pattern, '\d\+', '\=nr2char(submatch(0))', 'g')
   16              0.000007     endif
                            
   16              0.000016     if pattern ==# ''
                                  " ,
                                  call add(patterns, ',')
   16              0.000014     elseif pattern ==# '\'
                                  call add(patterns, '\\')
   16              0.000014     elseif pattern ==# '-'
                                  let has_dash = 1
   16              0.000006     else
                                  " Avoid ambiguous Python 3 RE syntax for nested sets
   16              0.000034       if pattern =~# '^--'
                                    let pattern = '\' . pattern
   16              0.000032       elseif pattern =~# '--$'
                                    let pattern = split(pattern, '-')[0] . '-\-'
   16              0.000006       endif
                            
   16              0.000029       call add(patterns, pattern)
   16              0.000006     endif
   20              0.000016   endfor
                            
                              " Dash must be last.
    4              0.000003   if has_dash
                                call add(patterns, '-')
    4              0.000002   endif
                            
    4   0.000281   0.000039   return join(deoplete#util#uniq(patterns), '')

FUNCTION  remote#host#Require()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/autoload/remote/host.vim:33
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000002   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
    1              0.000000   endif
    1              0.000003   let host = s:hosts[a:name]
    1              0.000001   if !host.channel && !host.initialized
                                let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
                                let host.channel = call(host.factory, [host_info])
                                let host.initialized = 1
    1              0.000000   endif
    1              0.000001   return host.channel

FUNCTION  dein#util#_get_lazy_plugins()
    Defined: ~/.cache/dein/repos/github.com/Shougo/dein.vim/autoload/dein/util.vim:624
Called 31 times
Total time:   0.001464
 Self time:   0.001464

count  total (s)   self (s)
   31              0.001448   return filter(values(g:dein#_plugins), "!v:val.sourced && v:val.rtp !=# ''")

FUNCTION  <SNR>47_Tree()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/fugitive.vim:164
Called 289 times
Total time:   0.002670
 Self time:   0.002670

count  total (s)   self (s)
  289              0.000380   let dir = a:path
  289              0.001367   if dir =~# '/\.git$'
  288              0.000770     return len(dir) ==# 5 ? '/' : dir[0:-6]
    1              0.000001   elseif dir ==# ''
    1              0.000001     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  remote#define#FunctionOnChannel()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/autoload/remote/define.vim:159
Called 1 time
Total time:   0.000056
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000004   let rpcargs = [a:channel, '"'.a:method.'"', 'a:000']
    1              0.000002   if has_key(a:opts, 'range')
                                call add(rpcargs, '[a:firstline, a:lastline]')
    1              0.000000   endif
    1   0.000014   0.000006   call s:AddEval(rpcargs, a:opts)
                            
    1   0.000030   0.000019   let function_def = s:GetFunctionPrefix(a:name, a:opts) . 'return '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')' . "\nendfunction"
    1              0.000004   exe function_def

FUNCTION  <SNR>84_on_text_document_did_change()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp.vim:258
Called 2 times
Total time:   0.000089
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000004     let l:buf = bufnr('%')
    2              0.000008     if getbufvar(l:buf, '&buftype') ==# 'terminal' | return | endif
    2   0.000022   0.000010     call lsp#log('s:on_text_document_did_change()', l:buf)
    2   0.000054   0.000012     call s:add_didchange_queue(l:buf)

FUNCTION  denite#init#_deprecated_options()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/init.vim:153
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003   return {}

FUNCTION  <SNR>105_expand()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:19
Called 7 times
Total time:   0.000757
 Self time:   0.000690

count  total (s)   self (s)
    7   0.000752   0.000685   return s:substitute_path_separator(expand(a:path))

FUNCTION  lsp#log()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp.vim:41
Called 10 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
   10              0.000025     if !empty(g:lsp_log_file)
                                    call writefile([strftime('%c') . ':' . json_encode(a:000)], g:lsp_log_file, 'a')
   10              0.000004     endif

FUNCTION  defx#util#has_yarp()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/defx/util.vim:205
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000007   return !has('nvim')

FUNCTION  <SNR>85_Tree()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:279
Called 288 times
Total time:   0.016121
 Self time:   0.001902

count  total (s)   self (s)
  288   0.016029   0.001811   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  <SNR>78_clear_region()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious/switcher/outer_region.vim:79
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007   silent! execute 'syntax clear' s:syntax_region_name
    1              0.000001   unlet! b:precious_prev_context_range

FUNCTION  indent_guides#lighten_or_darken_color()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:153
Called 22 times
Total time:   0.002916
 Self time:   0.000442

count  total (s)   self (s)
   22              0.000027   let l:new_color = ''
                            
   22              0.000037   if (&g:background == 'dark')
   22   0.002743   0.000269     let l:new_color = color_helper#hex_color_lighten(a:color, s:change_percent)
                              else
                                let l:new_color = color_helper#hex_color_darken (a:color, s:change_percent)
   22              0.000009   endif
                            
   22              0.000014   return l:new_color

FUNCTION  FugitiveWorkTree()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/fugitive.vim:151
Called 288 times
Total time:   0.014219
 Self time:   0.002912

count  total (s)   self (s)
  288   0.014123   0.002816   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  <SNR>162_Flag_print_width()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/config.vim:75
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000004   let l:value = get(a:config, 'printWidth', g:prettier#config#print_width)
                            
    1              0.000001   if (l:value ==# 'auto')
    1              0.000002     let l:value = &textwidth
    1              0.000000   endif
                            
    1              0.000001   if (l:value > 0)
                                return '--print-width=' . l:value
    1              0.000001   else
    1              0.000001     return ''
                              endif

FUNCTION  <SNR>29_LoadIndent()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/indent.vim:13
Called 3 times
Total time:   0.000456
 Self time:   0.000456

count  total (s)   self (s)
    3              0.000007     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    3              0.000001     endif
    3              0.000008     let s = expand("<amatch>")
    3              0.000004     if s != ""
    3              0.000004       if exists("b:did_indent")
                            	unlet b:did_indent
    3              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    6              0.000017       for name in split(s, '\.')
    3              0.000388 	exe 'runtime! indent/' . name . '.vim'
    6              0.000005       endfor
    3              0.000001     endif

FUNCTION  <SNR>77_doautocmd_user()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious/switcher/autocmd_context_filetype.vim:15
Called 3 times
Total time:   0.000249
 Self time:   0.000129

count  total (s)   self (s)
    3              0.000007 	if !has_key(s:cache_command, a:command)
    1              0.000009 		execute "autocmd " . s:group			"User " . a:command." silent! execute ''"
    1              0.000002 		if v:version > 703 || v:version == 703 && has("patch438")
    1              0.000003 			let s:cache_command[a:command] = "doautocmd <nomodeline> User " . a:command
                            		else
                            			let s:cache_command[a:command] = "doautocmd User " . a:command
    1              0.000000 		endif
    3              0.000001 	endif
                            
    3   0.000209   0.000089 	execute s:cache_command[a:command]

FUNCTION  prettier#job#async#neovim#run()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/job/async/neovim.vim:3
Called 1 time
Total time:   0.001250
 Self time:   0.001250

count  total (s)   self (s)
    1              0.000002   if s:prettier_job_running == 1
                                return
    1              0.000001   endif
    1              0.000001   let s:prettier_job_running = 1
                            
    1              0.000007   let l:lines = getline(a:startSelection, a:endSelection)
    1              0.000006   let l:dict = { 'start': a:startSelection - 1, 'end': a:endSelection, 'buf_nr': bufnr('%'), 'content': l:lines,}
    1              0.000001   let l:out = []
    1              0.000001   let l:err = []
                            
    1              0.001204   let l:job = jobstart([&shell, &shellcmdflag, a:cmd], { 'stdout_buffered': 1, 'stderr_buffered': 1, 'on_stdout': {job_id, data, event -> extend(l:out, data)}, 'on_stderr': {job_id, data, event -> extend(l:err, data)}, 'on_exit': {job_id, status, event -> s:onExit(status, l:dict, l:out, l:err)}, })
    1              0.000017   call jobsend(l:job, l:lines)
    1              0.000002   call jobclose(l:job, 'stdin')

FUNCTION  <SNR>35_get_prefix()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/utils.vim:18
Called 2 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    2              0.000071     return matchstr(a:path, '\(^\w\+::\|^\w\+://\)')

FUNCTION  denite#init#_check_channel()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/init.vim:11
Called 5 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    5              0.000014   return exists('g:denite#_channel_id')

FUNCTION  deoplete#util#get_input()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/util.vim:27
Called 8 times
Total time:   0.000245
 Self time:   0.000245

count  total (s)   self (s)
    8              0.000029   let mode = mode()
    8              0.000013   if a:event ==# 'InsertEnter'
                                let mode = 'i'
    8              0.000005   endif
    8              0.000146   let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
    8              0.000009   if a:event ==# 'InsertCharPre'
                                let input .= v:char
    8              0.000003   endif
                            
    8              0.000007   return input

FUNCTION  <SNR>162_Flag_range_delimiter()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/config.vim:39
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   if (!a:partialFormatEnabled)
    1              0.000001     return ''
                              endif
                            
                              let l:range = prettier#utils#buffer#getCharRange(a:start, a:end)
                            
                              return '--range-start=' . l:range[0] . ' --range-end=' . l:range[1]

FUNCTION  <SNR>84_on_text_document_did_close()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp.vim:319
Called 4 times
Total time:   0.000079
 Self time:   0.000053

count  total (s)   self (s)
    4              0.000013     let l:buf = bufnr('%')
    4              0.000015     if getbufvar(l:buf, '&buftype') ==# 'terminal' | return | endif
    4   0.000046   0.000020     call lsp#log('s:on_text_document_did_close()', l:buf)

FUNCTION  prettier#resolver#config#resolve()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/config.vim:3
Called 1 time
Total time:   0.000954
 Self time:   0.000110

count  total (s)   self (s)
                              " Allow params to be passed as json format
                              " convert bellow usage of globals to a get function o the params defaulting to global
                              " TODO: Use a list, filter() and join() to get a nicer list of args.
    1   0.000950   0.000106   let l:cmd = s:Flag_use_tabs(a:config) . ' ' . s:Flag_tab_width(a:config) . ' ' . s:Flag_print_width(a:config) . ' ' . s:Flag_parser(a:config) . ' ' . s:Flag_range_delimiter(a:config, a:hasSelection, a:start, a:end) . ' ' . ' --semi=' . get(a:config, 'semi', g:prettier#config#semi) . ' --single-quote=' . get(a:config, 'singleQuote', g:prettier#config#single_quote) . ' --bracket-spacing=' . get(a:config, 'bracketSpacing', g:prettier#config#bracket_spacing) . ' --jsx-bracket-same-line=' . get(a:config, 'jsxBracketSameLine', g:prettier#config#jsx_bracket_same_line) . ' --arrow-parens=' . get(a:config, 'arrowParens', g:prettier#config#arrow_parens) . ' --trailing-comma=' . get(a:config, 'trailingComma', g:prettier#config#trailing_comma) . ' --config-precedence=' . get(a:config, 'configPrecedence', g:prettier#config#config_precedence) . ' --prose-wrap=' . get(a:config, 'proseWrap', g:prettier#config#prose_wrap) . ' --html-whitespace-sensitivity ' . get(a:config, 'htmlWhitespaceSensitivity', g:prettier#config#html_whitespace_sensitivity) . ' --stdin-filepath="'.simplify(expand('%:p')).'"' . ' --require-pragma=' . get(a:config, 'requirePragma', g:prettier#config#require_pragma) . ' --loglevel error '. ' --stdin '
    1              0.000001   return l:cmd

FUNCTION  <SNR>160_ResolveExecutable()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/executable.vim:60
Called 2 times
Total time:   0.000192
 Self time:   0.000046

count  total (s)   self (s)
    2              0.000004   let l:rootDir = a:0 > 0 ? a:1 : 0
    2              0.000002   let l:exec = -1
                            
    2              0.000009   if isdirectory(l:rootDir)
    1   0.000150   0.000009     let l:dir = s:TraverseAncestorDirSearch(l:rootDir)
    1              0.000001     if l:dir != -1
                                  let l:exec = s:GetExecPath(l:dir)
    1              0.000000     endif
    1              0.000000   else
    1   0.000011   0.000006     let l:exec = s:GetExecPath()
    2              0.000001   endif
                            
    2              0.000001   return l:exec

FUNCTION  lightline#update()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lightline.vim:13
Called 8 times
Total time:   0.012712
 Self time:   0.000390

count  total (s)   self (s)
    8              0.000025   if &buftype ==# 'popup' | return | endif
    8              0.000007   if s:_
                                if s:_ == 2 | return | endif
                                call lightline#init()
                                call lightline#colorscheme()
    8              0.000003   endif
    8              0.000013   if !s:lightline.enable.statusline
                                return
    8              0.000002   endif
    8              0.000014   let w = winnr()
    8   0.012426   0.000104   let s = winnr('$') == 1 && w > 0 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
   24              0.000033   for n in range(1, winnr('$'))
   16              0.000113     call setwinvar(n, '&statusline', s[n!=w])
   24              0.000013   endfor

FUNCTION  denite#helper#_start_update_buffer_timer()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/helper.vim:258
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000023   return timer_start(50, {-> denite#_update_map('update_buffer', a:bufnr, v:false)}, {'repeat': -1})

FUNCTION  <SNR>154_re_unquoted_match()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/helper.vim:115
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
                              " Don't match a:match if it is located in-between unescaped single or double
                              " quotes
    1              0.000007   return a:match . '\v\ze([^"' . "'" . '\\]*(\\.|"([^"\\]*\\.)*[^"\\]*"|' . "'" . '([^' . "'" . '\\]*\\.)*[^' . "'" . '\\]*' . "'" . '))*[^"' . "'" . ']*$'

FUNCTION  dein#autoload#_on_default_event()
    Defined: ~/.cache/dein/repos/github.com/Shougo/dein.vim/autoload/dein/autoload.vim:77
Called 20 times
Total time:   0.005215
 Self time:   0.004025

count  total (s)   self (s)
   20   0.001070   0.000152   let lazy_plugins = dein#util#_get_lazy_plugins()
   20              0.000022   let plugins = []
                            
   20              0.000569   let path = expand('<afile>')
                              " For ":edit ~".
   20              0.000060   if fnamemodify(path, ':t') ==# '~'
                                let path = '~'
   20              0.000011   endif
   20   0.000363   0.000145   let path = dein#util#_expand(path)
                            
   39              0.000117   for filetype in split(&l:filetype, '\.')
   19              0.000718     let plugins += filter(copy(lazy_plugins), "index(get(v:val, 'on_ft', []), filetype) >= 0")
   39              0.000031   endfor
                            
   20              0.001016   let plugins += filter(copy(lazy_plugins), "!empty(filter(copy(get(v:val, 'on_path', [])),                'path =~? v:val'))")
   20              0.000865   let plugins += filter(copy(lazy_plugins), "!has_key(v:val, 'on_event')  && has_key(v:val, 'on_if') && eval(v:val.on_if)")
                            
   20   0.000238   0.000184   call s:source_events(a:event, plugins)

FUNCTION  <SNR>105_resolve()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:252
Called 14 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
   14              0.000036   return g:neomru#follow_links ? resolve(a:fpath) : a:fpath

FUNCTION  <SNR>47_Slash()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/fugitive.vim:313
Called 289 times
Total time:   0.001256
 Self time:   0.001256

count  total (s)   self (s)
  289              0.000461   if exists('+shellslash')
                                return tr(a:path, '\', '/')
  289              0.000104   else
  289              0.000237     return a:path
                              endif

FUNCTION  <SNR>84_send_didchange_queue()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp.vim:922
Called 1 time
Total time:   0.000138
 Self time:   0.000075

count  total (s)   self (s)
    1   0.000025   0.000013     call lsp#log('s:send_event_queue()')
    2              0.000005     for l:buf in s:didchange_queue
    1              0.000003         if !bufexists(l:buf)
                                        continue
    1              0.000001         endif
    1   0.000087   0.000036         for l:server_name in lsp#get_whitelisted_servers(l:buf)
                                        call s:ensure_flush(l:buf, l:server_name, function('s:Noop'))
    1              0.000001         endfor
    2              0.000002     endfor
    1              0.000002     let s:didchange_queue = []

FUNCTION  <SNR>35_urlencode_char()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/utils.vim:14
Called 4 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    4              0.000013     return printf('%%%02X', char2nr(a:c))

FUNCTION  <SNR>85_can_diffoff()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:4786
Called 7 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    7              0.000043   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  deoplete#custom#_init_buffer()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/custom.vim:20
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000001   let b:custom = {}
    1              0.000001   let b:custom.option = {}
    1              0.000001   let b:custom.source_vars = {}
    1              0.000001   let b:custom.filter = {}

FUNCTION  lsp#ui#vim#document_format_sync()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/ui/vim.vim:235
Called 1 time
Total time:   0.000148
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000005     let l:mode = mode()
    1              0.000009     if l:mode =~# '[vV]' || l:mode ==# "\<C-V>"
                                    return s:document_format_range(1)
    1              0.000001     endif
    1   0.000129   0.000008     return s:document_format(1)

FUNCTION  <SNR>83_flatten_twice()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lightline.vim:347
Called 26 times
Total time:   0.000461
 Self time:   0.000461

count  total (s)   self (s)
   26              0.000025   let ys = []
   73              0.000061   for xs in a:xss
  142              0.000079     for x in xs
   95              0.000082       let ys += x
  142              0.000057     endfor
   73              0.000038   endfor
   26              0.000018   return ys

FUNCTION  <SNR>55_is_enable_switch_CursorMoved()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/precious.vim:24
Called 11 times
Total time:   0.000449
 Self time:   0.000104

count  total (s)   self (s)
   11   0.000443   0.000099   return precious#switch_def(g:precious_enable_switch_CursorMoved, a:filetype, 1)

FUNCTION  <SNR>80_get_context()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:581
Called 76 times
Total time:   0.007208
 Self time:   0.003815

count  total (s)   self (s)
   76              0.000196   let base_filetype = empty(a:filetype) ? 'nothing' : a:filetype
   76              0.000199   let context_filetypes = get(a:context_filetypes, base_filetype, [])
   76              0.000104   if empty(context_filetypes)
   42              0.000032     return s:null_context
   34              0.000015   endif
                            
   34              0.000087   let pos = [line('.'), col('.')]
                            
   68              0.000086   for context in context_filetypes
   34              0.000062     if has_key(context, 'synname_pattern')
                                  for id in synstack(line('.'), col('.'))
                                    let synname = synIDattr(id, 'name')
                                    if synname =~# context.synname_pattern
                                      return {'filetype' : context.filetype, 'range': s:null_range, 'synname': synname}
                                    endif
                                  endfor
                                  continue
   34              0.000014     endif
                            
   34   0.003728   0.000335     let range = s:search_range(context.start, context.end)
                            
                                " Set cursor position
   34              0.000064     let start = range[0]
   34              0.000122     let end   = [range[1][0], (mode() ==# 'i') ? range[1][1]+1 : range[1][1]]
                            
                                " start <= pos && pos <= end
                                " search_range[0] <= start && start <= search_range[1]
                                " search_range[0] <= end   && end   <= search_range[1]
   34              0.000193     if range != s:null_range  && s:is_in(start, end, pos)  && s:is_in(a:search_range[0], a:search_range[1], range[0])  && s:is_in(a:search_range[0], a:search_range[1], range[1])
                                  let context_filetype = context.filetype
                                  if context.filetype =~# '\\\d\+'
                                    let stopline_back = s:stopline_back()
                                    let lines = getline( searchpos(context.start, 'nbW', stopline_back)[0], line('.') )
                                    let match_list = matchlist(join(lines, "\n"), context.start)
                                    let context_filetype = s:replace_submatch(context.filetype, match_list)
                                  endif
                                  return {'filetype' : context_filetype, 'range' : range}
   34              0.000015     endif
   68              0.000164   endfor
                            
   34              0.000031   return s:null_context

FUNCTION  context_filetype#get()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:26
Called 38 times
Total time:   0.012150
 Self time:   0.000849

count  total (s)   self (s)
   38              0.000090   let base_filetype = get(a:, 1, &filetype)
   38   0.002601   0.000234   let filetypes = context_filetype#filetypes()
   38   0.009224   0.000290   let context = s:get_nest(base_filetype, filetypes)
   38              0.000085   if context.range == s:null_range && !has_key(context, 'synname')
   38              0.000063     let context.filetype = base_filetype
   38              0.000016   endif
   38              0.000025   return context

FUNCTION  precious#autocmd_switch()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious.vim:161
Called 22 times
Total time:   0.006480
 Self time:   0.000262

count  total (s)   self (s)
   22              0.000019 	try
   22   0.006360   0.000141 		call call("precious#switch", a:000)
                            	catch
                            		echo "Throw precious#autocmd_switch() : Please 'echo precious#log()'"
                            		let s:switch_last_error_msg = v:throwpoint . " : " . v:errmsg . " : " . v:exception
   22              0.000016 	endtry

FUNCTION  <SNR>27_ftplugin()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/ftplugin.vim:10
Called 3 times
Total time:   0.003981
 Self time:   0.003980

count  total (s)   self (s)
    3              0.000008   if exists("b:undo_ftplugin")
                                silent! execute b:undo_ftplugin
                                unlet! b:undo_ftplugin b:did_ftplugin
    3              0.000001   endif
                            
    3              0.000008   let filetype = expand("<amatch>")
    3              0.000004   if filetype !=# ""
    3              0.000012     if &cpoptions =~# "S" && exists("b:did_ftplugin")
                                  unlet b:did_ftplugin
    3              0.000001     endif
    6              0.000018     for ft in split(filetype, '\.')
    3              0.003869       execute "runtime! ftplugin/" . ft . ".vim" "ftplugin/" . ft . "_*.vim" "ftplugin/" . ft . "/*.vim"
    6              0.000007     endfor
    3              0.000002   endif
    3   0.000028   0.000027   call s:after_ftplugin()

FUNCTION  deoplete#util#convert2list()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/util.vim:20
Called 10 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
   10              0.000033   return type(a:expr) ==# v:t_list ? a:expr : [a:expr]

FUNCTION  lsp#utils#error()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/utils.vim:163
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000022     echohl ErrorMsg
    1              0.000019     echom a:msg
    1              0.000004     echohl NONE

FUNCTION  deoplete#util#vimoption2python()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/util.vim:48
Called 4 times
Total time:   0.000830
 Self time:   0.000035

count  total (s)   self (s)
    4   0.000828   0.000033   return '[\w' . s:vimoption2python(a:option) . ']'

FUNCTION  prettier#utils#quickfix#close()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/utils/quickfix.vim:4
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
                              " close quickfix if it is opened
    1              0.000002   if s:prettier_quickfix_open
                                call setqflist([], 'r')
                                cclose
                                let s:prettier_quickfix_open = 0
    1              0.000001   endif

FUNCTION  precious#base_filetype()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious.vim:11
Called 45 times
Total time:   0.000339
 Self time:   0.000337

count  total (s)   self (s)
   45              0.000131 	if !has_key(b:, "precious_base_filetype")
    1   0.000008   0.000006 		call precious#set_base_filetype(&filetype)
   45              0.000026 	endif
   45              0.000055 	return b:precious_base_filetype

FUNCTION  deoplete#util#uniq()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/util.vim:90
Called 4 times
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
    4              0.000033   let list = map(copy(a:list), '[v:val, v:val]')
    4              0.000003   let i = 0
    4              0.000004   let seen = {}
   20              0.000024   while i < len(list)
   16              0.000034     let key = string(list[i][1])
   16              0.000022     if has_key(seen, key)
                                  call remove(list, i)
   16              0.000006     else
   16              0.000021       let seen[key] = 1
   16              0.000011       let i += 1
   16              0.000005     endif
   20              0.000011   endwhile
    4              0.000021   return map(list, 'v:val[0]')

FUNCTION  <SNR>3_source_events()
    Defined: ~/.cache/dein/repos/github.com/Shougo/dein.vim/autoload/dein/autoload.vim:114
Called 20 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
   20              0.000030   if empty(a:plugins)
   20              0.000013     return
                              endif
                            
                              let prev_autocmd = execute('autocmd ' . a:event)
                            
                              call dein#autoload#_source(a:plugins)
                            
                              let new_autocmd = execute('autocmd ' . a:event)
                            
                              if a:event ==# 'InsertCharPre'
                                " Queue this key again
                                call feedkeys(v:char)
                                let v:char = ''
                              else
                                if exists('#BufReadCmd') && a:event ==# 'BufNew'
                                  " For BufReadCmd plugins
                                  silent doautocmd <nomodeline> BufReadCmd
                                endif
                                if exists('#' . a:event) && prev_autocmd !=# new_autocmd
                                  execute 'doautocmd <nomodeline>' a:event
                                elseif exists('#User#' . a:event)
                                  execute 'doautocmd <nomodeline> User' a:event
                                endif
                              endif

FUNCTION  22()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious/switcher/autocmd_context_filetype.vim:30
Called 1 time
Total time:   0.000290
 Self time:   0.000041

count  total (s)   self (s)
    1              0.000002 	let context_filetype = a:context.context_filetype
    1              0.000002 	let prev_context_filetype = a:context.prev_context_filetype
                            
    1   0.000116   0.000007 	call s:doautocmd_user("PreciousFileTypeLeave_".prev_context_filetype)
    1   0.000073   0.000007 	call s:doautocmd_user("PreciousFileType")
    1   0.000096   0.000022 	call s:doautocmd_user("PreciousFileType_".context_filetype)

FUNCTION  24()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious/switcher/setfiletype.vim:8
Called 1 time
Total time:   0.004848
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000002 	let base_filetype = a:context.base_filetype
    1              0.000001 	let filetype = a:context.context_filetype
    1   0.004838   0.000006 	let &filetype = filetype
    1   0.000007   0.000005 	call precious#set_base_filetype(base_filetype)

FUNCTION  <SNR>105_uniq_by()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:399
Called 4 times
Total time:   0.027015
 Self time:   0.027015

count  total (s)   self (s)
    4              0.004639   let list = map(copy(a:list), printf('[v:val, %s]', a:f))
    4              0.000009   let i = 0
    4              0.000005   let seen = {}
 2116              0.002354   while i < len(list)
 2112              0.005008     let key = string(list[i][1])
 2112              0.003163     if has_key(seen, key)
                                  call remove(list, i)
 2112              0.000795     else
 2112              0.003440       let seen[key] = 1
 2112              0.001391       let i += 1
 2112              0.000798     endif
 2116              0.000795   endwhile
    4              0.001840   return map(list, 'v:val[0]')

FUNCTION  33()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:139
Called 4 times
Total time:   0.137051
 Self time:   0.001492

count  total (s)   self (s)
    4   0.000066   0.000038   if s:is_sudo()
                                return
    4              0.000002   endif
                            
    4              0.000014   let opts = a:0 >= 1 && type(a:1) == type({}) ? a:1 : {}
                            
    4   0.000094   0.000048   if self.has_external_update() && filereadable(self.mru_file)
                                " only need to get the list which contains the latest MRUs
                                let lines = readfile(self.mru_file)
                                if !empty(lines)
                                  let [ver; items] = lines
                                  if self.version_check(ver)
                                    call extend(self.candidates, items)
                                  endif
                                endif
    4              0.000001   endif
                            
    4   0.027767   0.000423   let self.candidates = s:uniq(self.candidates)
    4              0.000018   if len(self.candidates) > self.limit
                                let self.candidates = self.candidates[: self.limit - 1]
    4              0.000003   endif
                            
    4              0.000010   if get(opts, 'event') ==# 'VimLeavePre'
    4   0.106642   0.000062     call self.validate()
    4              0.000001   endif
                            
    4   0.002297   0.000736   call s:writefile(self.mru_file, [self.version] + self.candidates)
                            
    4              0.000066   let self.mtime = getftime(self.mru_file)

FUNCTION  34()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:172
Called 12 times
Total time:   0.000347
 Self time:   0.000168

count  total (s)   self (s)
   12              0.000051   let is_force = get(a:000, 0, 0)
                            
                              " everything is loaded, done!
   12   0.000261   0.000082   if !is_force && self.is_loaded && !self.has_external_update()
   12              0.000012     return
                              endif
                            
                              let mru_file = self.mru_file
                            
                              if !filereadable(mru_file)
                                return
                              endif
                            
                              let file = readfile(mru_file)
                              if empty(file)
                                return
                              endif
                            
                              let [ver; items] = file
                              if !self.version_check(ver)
                                return
                              endif
                            
                              if self.type ==# 'file'
                              endif
                            
                              " Assume properly saved and sorted. unique sort is not necessary here
                              call extend(self.candidates, items)
                            
                              if self.is_loaded
                                let self.candidates = s:uniq(self.candidates)
                              endif
                            
                              let self.mtime = getftime(mru_file)
                              let self.is_loaded = 1

FUNCTION  36()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:216
Called 12 times
Total time:   0.087729
 Self time:   0.000182

count  total (s)   self (s)
   12   0.000398   0.000051   call self.load()
   12              0.000050   let index = index(self.candidates, a:path)
   12              0.000010   if index == 0
   10              0.000004     return
    2              0.000001   endif
                            
    2              0.000001   if index > 0
    2              0.000005     call remove(self.candidates, index)
    2              0.000001   endif
    2              0.000004   call insert(self.candidates, a:path)
                            
    2              0.000003   if len(self.candidates) > self.limit
                                let self.candidates = self.candidates[: self.limit - 1]
    2              0.000001   endif
                            
    2              0.000016   if localtime() > getftime(self.mru_file) + self.update_interval
    2   0.087212   0.000013     call self.save()
    2              0.000002   endif

FUNCTION  39()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:280
Called 1 time
Total time:   0.001685
 Self time:   0.001685

count  total (s)   self (s)
    1              0.000001   if self.do_validate
    1              0.001680     call filter(self.candidates, 'getftype(v:val) ==# "dir"')
    1              0.000003   endif

FUNCTION  dein#autoload#_on_func()
    Defined: ~/.cache/dein/repos/github.com/Shougo/dein.vim/autoload/dein/autoload.vim:142
Called 11 times
Total time:   0.001831
 Self time:   0.001053

count  total (s)   self (s)
   11              0.000120   let function_prefix = substitute(a:name, '[^#]*$', '', '')
   11              0.000085   if function_prefix =~# '^dein#' || function_prefix =~# '^vital#' || has('vim_starting')
                                return
   11              0.000006   endif
                            
   11   0.001595   0.000817   call dein#autoload#_source(filter(dein#util#_get_lazy_plugins(),  "stridx(function_prefix, v:val.normalized_name.'#') == 0   || (index(get(v:val, 'on_func', []), a:name) >= 0)"))

FUNCTION  FugitiveIsGitDir()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/fugitive.vim:155
Called 1 time
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    1              0.000037   let path = substitute(a:path, '[\/]$', '', '') . '/'
    1              0.000044   return len(a:path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>63_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/plugin/matchparen.vim:39
Called 17 times
Total time:   0.000942
 Self time:   0.000942

count  total (s)   self (s)
                              " Remove any previous match.
   17              0.000037   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
   17              0.000007   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   17              0.000044   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   17              0.000005   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   17              0.000029   let c_lnum = line('.')
   17              0.000026   let c_col = col('.')
   17              0.000013   let before = 0
                            
   17              0.000031   let text = getline(c_lnum)
   17              0.000154   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   17              0.000021   if empty(matches)
                                let [c_before, c] = ['', '']
   17              0.000008   else
   17              0.000047     let [c_before, c] = matches[1:2]
   17              0.000007   endif
   17              0.000178   let plist = split(&matchpairs, '.\zs[:,]')
   17              0.000038   let i = index(plist, c)
   17              0.000013   if i < 0
                                " not found, in Insert mode try character before the cursor
   17              0.000034     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   17              0.000007     endif
   17              0.000010     if i < 0
                                  " not found, nothing to do
   17              0.000010       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  color_helper#rgb_color_to_hex()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/color_helper.vim:58
Called 22 times
Total time:   0.000807
 Self time:   0.000561

count  total (s)   self (s)
   22              0.000024   let l:hex_color  = '#'
   22   0.000274   0.000177   let l:hex_color .= color_helper#dec_to_hex(a:rgb_color[0], 2) " red
   22   0.000226   0.000153   let l:hex_color .= color_helper#dec_to_hex(a:rgb_color[1], 2) " green
   22   0.000240   0.000165   let l:hex_color .= color_helper#dec_to_hex(a:rgb_color[2], 2) " blue
                            
   22              0.000017   return l:hex_color

FUNCTION  <SNR>75_is_enable_switch()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious.vim:59
Called 3 times
Total time:   0.000186
 Self time:   0.000040

count  total (s)   self (s)
    3   0.000102   0.000022 	let def = precious#switch_def(g:precious_enable_switchers, a:filetype, {})
    3   0.000082   0.000017 	return precious#switch_def(def, a:switch, 1)

FUNCTION  <SNR>75_prev_context_filetype()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious.vim:51
Called 22 times
Total time:   0.000199
 Self time:   0.000194

count  total (s)   self (s)
   22              0.000101 	if !exists("b:precious_prev_context_filetype")
    1   0.000010   0.000005 		let b:precious_prev_context_filetype = precious#base_filetype()
   22              0.000011 	endif
   22              0.000025 	return b:precious_prev_context_filetype

FUNCTION  lightline#link()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lightline.vim:217
Called 99 times
Total time:   0.004461
 Self time:   0.004461

count  total (s)   self (s)
   99              0.000733   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
   99              0.000153   if s:mode ==# mode
   92              0.000073     return ''
    7              0.000006   endif
    7              0.000010   let s:mode = mode
    7              0.000015   if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
    7              0.000003   endif
    7              0.000079   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
   21              0.000056   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
   70              0.000164     for [i, t] in map(range(0, l), '[v:val, 0]') + types
   56              0.000040       if i != l
   42              0.000417         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
   56              0.000023       endif
  280              0.000487       for [j, s] in map(range(0, l), '[v:val, 0]') + types
  224              0.000283         if i + 1 == j || t || s && i != l
  112              0.000963           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
  224              0.000081         endif
  280              0.000092       endfor
   70              0.000028     endfor
   21              0.000015   endfor
    7              0.000048   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
    7              0.000007   return ''

FUNCTION  <SNR>79_reset_filetype()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious/switcher/setfiletype.vim:21
Called 4 times
Total time:   0.000089
 Self time:   0.000050

count  total (s)   self (s)
    4   0.000077   0.000038 	if &filetype != precious#base_filetype()
                            		let &filetype = precious#base_filetype()
    4              0.000002 	endif

FUNCTION  indent_guides#gui_highlight_colors()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:120
Called 11 times
Total time:   0.003678
 Self time:   0.000762

count  total (s)   self (s)
   11              0.000014   let l:hi_normal_guibg = ''
                            
                              " capture the backgroud color from the normal highlight
   11              0.000077   if s:hi_normal =~ s:color_hex_bg_pat
                                " hex color code is being used, eg. '#FFFFFF'
   11              0.000073     let l:hi_normal_guibg = matchstr(s:hi_normal, s:color_hex_bg_pat)
                            
                              elseif s:hi_normal =~ s:color_name_bg_pat
                                " color name is being used, eg. 'white'
                                let l:color_name = matchstr(s:hi_normal, s:color_name_bg_pat)
                                let l:hi_normal_guibg = color_helper#color_name_to_hex(l:color_name)
                            
                              else
                                " background color could not be detected, default to basic colors
                                call indent_guides#basic_highlight_colors()
   11              0.000004   endif
                            
   11              0.000043   if l:hi_normal_guibg =~ s:color_hex_pat
                                " calculate the highlight background colors
   11   0.001661   0.000148     let l:hi_odd_bg  = indent_guides#lighten_or_darken_color(l:hi_normal_guibg)
   11   0.001476   0.000073     let l:hi_even_bg = indent_guides#lighten_or_darken_color(l:hi_odd_bg)
                            
                                " define the new highlights
   11              0.000124     exe 'hi IndentGuidesOdd  guibg=' . l:hi_odd_bg . ' guifg=' . l:hi_even_bg
   11              0.000077     exe 'hi IndentGuidesEven guibg=' . l:hi_even_bg . ' guifg=' . l:hi_odd_bg
   11              0.000005   end

FUNCTION  defx#util#rpcrequest()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/defx/util.vim:208
Called 2 times
Total time:   0.001738
 Self time:   0.001549

count  total (s)   self (s)
    2   0.000025   0.000014   if !defx#init#_check_channel()
                                return -1
    2              0.000001   endif
                            
    2   0.000023   0.000015   if defx#util#has_yarp()
                                if g:defx#_yarp.job_is_dead
                                  return -1
                                endif
                                if a:is_async
                                  return g:defx#_yarp.notify(a:method, a:args)
                                else
                                  return g:defx#_yarp.request(a:method, a:args)
                                endif
    2              0.000001   else
    2              0.000002     if a:is_async
                                  return rpcnotify(g:defx#_channel_id, a:method, a:args)
    2              0.000001     else
    2   0.001658   0.001489       return rpcrequest(g:defx#_channel_id, a:method, a:args)
                                endif
                              endif

FUNCTION  <SNR>85_Slash()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:104
Called 864 times
Total time:   0.003788
 Self time:   0.003788

count  total (s)   self (s)
  864              0.001495   if exists('+shellslash')
                                return tr(a:path, '\', '/')
  864              0.000331   else
  864              0.000567     return a:path
                              endif

FUNCTION  deoplete#util#get_next_input()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/util.vim:44
Called 4 times
Total time:   0.000144
 Self time:   0.000039

count  total (s)   self (s)
    4   0.000142   0.000037   return getline('.')[len(deoplete#util#get_input(a:event)) :]

FUNCTION  <SNR>160_GetExecPath()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/executable.vim:33
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000001   let l:rootDir = a:0 > 0 ? a:1 : -1
    1              0.000002   let l:dir = l:rootDir != -1 ? l:rootDir . '/.bin/' : ''
    1              0.000001   return l:dir . 'prettier'

FUNCTION  deoplete#util#has_yarp()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/util.vim:134
Called 6 times
Total time:   0.000109
 Self time:   0.000087

count  total (s)   self (s)
    6   0.000106   0.000084   return !has('nvim') || deoplete#custom#_get_option('yarp')

FUNCTION  lsp#get_whitelisted_servers()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp.vim:807
Called 4 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
    4              0.000008     if a:0 == 0
    1              0.000003         let l:buffer_filetype = &filetype
    3              0.000002     else
    3              0.000007         if type(a:1) == type('')
                                        let l:buffer_filetype = a:1
    3              0.000001         else
    3              0.000011             let l:buffer_filetype = getbufvar(a:1, '&filetype')
    3              0.000001         endif
    4              0.000001     endif
                            
                                " TODO: cache active servers per buffer
    4              0.000005     let l:active_servers = []
                            
    4              0.000016     for l:server_name in keys(s:servers)
                                    let l:server_info = s:servers[l:server_name]['server_info']
                                    let l:blacklisted = 0
                            
                                    if has_key(l:server_info, 'blacklist')
                                        for l:filetype in l:server_info['blacklist']
                                            if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
                                                let l:blacklisted = 1
                                                break
                                            endif
                                        endfor
                                    endif
                            
                                    if l:blacklisted
                                        continue
                                    endif
                            
                                    if has_key(l:server_info, 'whitelist')
                                        for l:filetype in l:server_info['whitelist']
                                            if l:filetype ==? l:buffer_filetype || l:filetype ==# '*'
                                                let l:active_servers += [l:server_name]
                                                break
                                            endif
                                        endfor
                                    endif
    4              0.000010     endfor
                            
    4              0.000004     return l:active_servers

FUNCTION  denite#init#_user_options()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/init.vim:97
Called 2 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
    2              0.000147   return { 'auto_action': '', 'auto_resize': v:false, 'auto_resume': v:false, 'buffer_name': 'default', 'cursor_pos': '', 'cursorline': v:true, 'default_action': 'default', 'direction': 'botright', 'do': '', 'empty': v:true, 'expand': v:false, 'filter_split_direction': 'botright', 'filter_updatetime': 100, 'floating_preview': v:false, 'highlight_filter_background': 'NormalFloat', 'highlight_matched_range': 'Underlined', 'highlight_matched_char': 'Search', 'highlight_preview_line': 'Search', 'highlight_prompt': 'Special', 'highlight_window_background': 'NormalFloat', 'ignorecase': v:true, 'immediately': v:false, 'immediately_1': v:false, 'input': '', 'matchers': '', 'match_highlight': v:false, 'max_candidate_width': 200, 'max_dynamic_update_candidates': 20000, 'path': getcwd(), 'preview_height': &previewheight, 'preview_width': 40, 'prompt': '', 'post_action': 'none', 'quick_move': '', 'refresh': v:false, 'resume': v:false, 'reversed': v:false, 'root_markers': '', 'search': v:false, 'smartcase': v:false, 'sorters': '', 'split': 'horizontal', 'source_names': '', 'start_filter': v:false, 'statusline': v:true, 'unique': v:false, 'vertical_preview': v:false, 'wincol': &columns / 4, 'winheight': 20, 'winrow': &lines / 2 - 10, 'winwidth': &columns / 2, 'winminheight': -1,}

FUNCTION  FugitiveVimPath()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/fugitive.vim:301
Called 289 times
Total time:   0.001526
 Self time:   0.001526

count  total (s)   self (s)
  289              0.000609   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
  289              0.000121   else
  289              0.000238     return a:path
                              endif

FUNCTION  indent_guides#highlight_colors()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:94
Called 11 times
Total time:   0.003838
 Self time:   0.000160

count  total (s)   self (s)
   11              0.000009   if s:auto_colors
   11              0.000040     if has('gui_running') || has('nvim')
   11   0.003745   0.000067       call indent_guides#gui_highlight_colors()
                                else
                                  call indent_guides#basic_highlight_colors()
   11              0.000005     endif
   11              0.000004   endif

FUNCTION  precious#context_filetype()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious.vim:29
Called 22 times
Total time:   0.009734
 Self time:   0.000379

count  total (s)   self (s)
   27              0.000085 	for matcher in values(s:matchers)
   22   0.009450   0.000123 		let filetype = matcher.apply()
   22              0.000037 		if !empty(filetype)
   17              0.000014 			return filetype
    5              0.000002 		endif
   10              0.000008 	endfor
    5   0.000084   0.000056 	return precious#base_filetype()

FUNCTION  FugitiveGitDir()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/fugitive.vim:11
Called 865 times
Total time:   0.016536
 Self time:   0.015286

count  total (s)   self (s)
  865              0.001974   if !a:0 || type(a:1) == type(0) && a:1 < 0
  577              0.000944     if exists('g:fugitive_event')
                                  return g:fugitive_event
  577              0.000257     endif
  577              0.001253     let dir = get(b:, 'git_dir', '')
  577              0.001521     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
  577              0.000202     endif
  577              0.000380     return dir
  288              0.000494   elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
  288              0.000495   elseif type(a:1) == type('')
  288   0.003963   0.002713     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  <SNR>26_isNode()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/ftdetect/ftdetect.vim:46
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000002 	let shebang = getline(1)
    1              0.000005 	if shebang =~# '^#!.*/bin/env\s\+node\>' | return 1 | en
    1              0.000003 	if shebang =~# '^#!.*/bin/node\>' | return 1 | en
    1              0.000001 	return 0

FUNCTION  color_helper#hex_color_lighten()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/color_helper.vim:74
Called 22 times
Total time:   0.002474
 Self time:   0.000679

count  total (s)   self (s)
   22   0.001129   0.000140   let l:rgb = color_helper#hex_color_to_rgb(a:color)
   22              0.000038   let l:rgb_lightened = []
                            
   88              0.000067   for i in l:rgb
   66              0.000173     call add(l:rgb_lightened, float2nr(i + ((255 - i) * a:percent)))
   88              0.000048   endfor
                            
   22   0.000929   0.000123   return color_helper#rgb_color_to_hex(l:rgb_lightened)

FUNCTION  <SNR>80_stopline_forward()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:476
Called 34 times
Total time:   0.000219
 Self time:   0.000219

count  total (s)   self (s)
   34              0.000104   let stopline_forward = line('.') + g:context_filetype#search_offset
   34              0.000095   return (stopline_forward > line('$')) ? line('$') : stopline_forward

FUNCTION  prettier#job#runner#run()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/job/runner.vim:7
Called 1 time
Total time:   0.002046
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000002     if a:async && (s:isAsyncVim || s:isNeoVim)
    1   0.002038   0.000014       call s:asyncFormat(a:cmd, a:startSelection, a:endSelection)
                                else
                                  call s:format(a:cmd, a:startSelection, a:endSelection)
    1              0.000000     endif

FUNCTION  lsp#utils#get_buffer_uri()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/utils.vim:87
Called 2 times
Total time:   0.001466
 Self time:   0.000069

count  total (s)   self (s)
    2   0.001465   0.000069     return lsp#utils#path_to_uri(expand((a:0 > 0 ? '#' . a:1 : '%') . ':p'))

FUNCTION  deoplete#util#get_keyword_pattern()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/util.vim:138
Called 4 times
Total time:   0.001034
 Self time:   0.000178

count  total (s)   self (s)
    4   0.000045   0.000032   let keyword_patterns = deoplete#custom#_get_option('keyword_patterns')
    4              0.000006   if empty(keyword_patterns)
                                let patterns = deoplete#custom#_get_filetype_option(   'keyword_patterns', a:filetype, '')
    4              0.000002   else
    4              0.000011     let filetype = has_key(keyword_patterns, a:filetype) ? a:filetype : '_'
    4              0.000009     let patterns = get(keyword_patterns, filetype, '')
    4              0.000002   endif
    4   0.000044   0.000031   let pattern = join(deoplete#util#convert2list(patterns), '|')
                            
                              " Convert keyword.
    4   0.000874   0.000045   let k_pattern = deoplete#util#vimoption2python( &l:iskeyword . (&l:lisp ? ',-' : ''))
    4              0.000021   return substitute(pattern, '\\k', '\=k_pattern', 'g')

FUNCTION  <SNR>156_start()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite.vim:26
Called 1 time
Total time:   0.140769
 Self time:   0.000025

count  total (s)   self (s)
    1   0.001248   0.000005   if denite#initialize()
                                return
    1              0.000000   endif
                            
                              " Add current position to the jumplist.
    1              0.000002   let pos = getpos('.')
    1              0.000004   execute line('.')
    1              0.000002   call setpos('.', pos)
                            
    1              0.000002   let args = [a:sources, a:user_context]
    1   0.139508   0.000007   return denite#util#rpcrequest('_denite_start', args, v:false)

FUNCTION  denite#_update_map()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite.vim:72
Called 1 time
Total time:   0.001442
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000006   let is_filter = &l:filetype ==# 'denite-filter'
                            
    1   0.001428   0.000012   call denite#util#rpcrequest( (a:is_async ? '_denite_do_async_map' : '_denite_do_map'), [a:bufnr, a:name, []], a:is_async)
                            
    1              0.000002   if is_filter
                                call s:update_filter()
    1              0.000001   endif

FUNCTION  denite#custom#_get()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/custom.vim:7
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000007   if !exists('s:custom')
                                call denite#custom#_init()
    1              0.000001   endif
                            
    1              0.000001   return s:custom

FUNCTION  denite#util#has_yarp()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/util.vim:237
Called 6 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    6              0.000015   return !has('nvim')

FUNCTION  denite#initialize()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite.vim:7
Called 1 time
Total time:   0.001243
 Self time:   0.000005

count  total (s)   self (s)
    1   0.001243   0.000005   return denite#init#_initialize()

FUNCTION  <SNR>24_SynSet()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/syntax/synload.vim:33
Called 3 times
Total time:   0.001191
 Self time:   0.001191

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    3              0.000007   syn clear
    3              0.000006   if exists("b:current_syntax")
                                unlet b:current_syntax
    3              0.000002   endif
                            
    3              0.000007   let s = expand("<amatch>")
    3              0.000004   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    3              0.000003   elseif s == "OFF"
                                let s = ""
    3              0.000001   endif
                            
    3              0.000003   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
    6              0.000019     for name in split(s, '\.')
    3              0.001097       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    6              0.000008     endfor
    3              0.000002   endif

FUNCTION  lsp#get_server_status()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp.vim:121
Called 96 times
Total time:   0.001179
 Self time:   0.001179

count  total (s)   self (s)
   96              0.000135     if a:0 == 0
   96              0.000761         let l:strs = map(keys(s:servers), {k, v -> v . ': ' . s:server_status(v)})
   96              0.000199         return join(l:strs, "\n")
                                else
                                    return s:server_status(a:1)
                                endif

FUNCTION  FugitiveDetect()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/fugitive.vim:272
Called 1 time
Total time:   0.000414
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000002   if exists('b:git_dir') && b:git_dir =~# '^$\|/$\|^fugitive:'
                                unlet b:git_dir
    1              0.000000   endif
    1              0.000001   if !exists('b:git_dir')
    1   0.000303   0.000009     let dir = FugitiveExtractGitDir(a:path)
    1              0.000001     if dir !=# ''
    1              0.000002       let b:git_dir = dir
    1              0.000001     endif
    1              0.000000   endif
    1              0.000007   if !exists('b:git_dir') || !exists('#User#Fugitive')
                                return ''
    1              0.000000   endif
    1              0.000002   if v:version >= 704 || (v:version == 703 && has('patch442'))
    1   0.000080   0.000031     doautocmd <nomodeline> User Fugitive
                              elseif &modelines > 0
                                let modelines = &modelines
                                try
                                  set modelines=0
                                  doautocmd User Fugitive
                                finally
                                  let &modelines = modelines
                                endtry
                              else
                                doautocmd User Fugitive
    1              0.000000   endif
    1              0.000001   return ''

FUNCTION  <SNR>47_CeilingDirectories()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/fugitive.vim:198
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000002   if !exists('s:ceiling_directories')
                                let s:ceiling_directories = []
                                let resolve = 1
                                for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
                                  if empty(dir)
                                    let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, resolve(dir))
                                  else
                                    call add(s:ceiling_directories, dir)
                                  endif
                                endfor
    1              0.000000   endif
    1              0.000003   return s:ceiling_directories + get(g:, 'ceiling_directories', [])

FUNCTION  dein#util#_expand()
    Defined: ~/.cache/dein/repos/github.com/Shougo/dein.vim/autoload/dein/util.vim:583
Called 20 times
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
   20              0.000154   let path = (a:path =~# '^\~') ? fnamemodify(a:path, ':p') : (a:path =~# '^\$\h\w*') ? substitute(a:path,               '^\$\h\w*', '\=eval(submatch(0))', '') : a:path
   20              0.000051   return (s:is_windows && path =~# '\\') ? dein#util#_substitute_path(path) : path

FUNCTION  precious#switch()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious.vim:95
Called 22 times
Total time:   0.006219
 Self time:   0.000452

count  total (s)   self (s)
   22              0.000034 	let context_filetype = a:filetype
                            
   22   0.000434   0.000235 	let prev_context_filetype = s:prev_context_filetype()
   22              0.000053 	if context_filetype == prev_context_filetype
   21              0.000013 		return 0
    1              0.000000 	endif
                            
    1   0.000009   0.000004 	let base_filetype = precious#base_filetype()
    1              0.000004 	let context = {		"base_filetype" : base_filetype,		"context_filetype" : context_filetype,		"prev_context_filetype" : prev_context_filetype	}
                            
    1   0.000029   0.000020 	call precious#reset_contextlocal()
    1              0.000001 	try
    4              0.000010 		for [name, switcher] in items(s:switchers)
    3   0.000205   0.000020 			if s:is_enable_switch(name, base_filetype)
    3   0.005385   0.000016 				call switcher.apply(context)
    3              0.000002 			endif
    4              0.000002 		endfor
    1              0.000001 	finally
    1              0.000002 		let b:precious_prev_context_filetype = context_filetype
    1              0.000001 	endtry

FUNCTION  lsp#ui#vim#references#clean_references()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/ui/vim/references.vim:179
Called 7 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    7              0.000022     let s:pending[&filetype] = v:false
    7              0.000014     if exists('w:lsp_reference_matches')
                                    for l:match in w:lsp_reference_matches
                                        silent! call matchdelete(l:match)
                                    endfor
                                    unlet w:lsp_reference_matches
                                    unlet w:lsp_reference_positions
    7              0.000003     endif

FUNCTION  <SNR>125_MarkdownSetupFolding()
    Defined: ~/.cache/dein/repos/github.com/plasticboy/vim-markdown/after/ftplugin/markdown.vim:173
Called 3 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    3              0.000009     if !get(g:, "vim_markdown_folding_disabled", 0)
                                    if get(g:, "vim_markdown_folding_style_pythonic", 0)
                                        if get(g:, "vim_markdown_override_foldtext", 1)
                                            setlocal foldtext=Foldtext_markdown()
                                        endif
                                    endif
                                    setlocal foldexpr=Foldexpr_markdown(v:lnum)
                                    setlocal foldmethod=expr
    3              0.000001     endif

FUNCTION  21()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious/matcher/context_filetype_vim.vim:9
Called 22 times
Total time:   0.009327
 Self time:   0.000583

count  total (s)   self (s)
   22   0.000285   0.000146 	let base_filetype = precious#base_filetype()
   22              0.000027 	let has_contextfiletype_vim = 0
   22   0.000315   0.000206 	silent! let has_contextfiletype_vim = context_filetype#version()
   22              0.000019 	if has_contextfiletype_vim
   22   0.008654   0.000158 		return context_filetype#get_filetype(base_filetype)
                            	else
                            		echo "precious.vim - Please install context_filetype.vim"
                            		return ""
                            	endif

FUNCTION  23()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious/switcher/outer_region.vim:9
Called 1 time
Total time:   0.000231
 Self time:   0.000036

count  total (s)   self (s)
    1              0.000001   let has_contextfiletype_vim = 0
    1   0.000025   0.000021   silent! let has_contextfiletype_vim = context_filetype#version()
    1              0.000001   if !has_contextfiletype_vim
                                echo "precious.vim - Please install context_filetype.vim"
                                return ""
    1              0.000000   endif
                            
    1              0.000002   if a:context.base_filetype !=# a:context.context_filetype
                                call s:start_region_update()
    1              0.000000   else
    1   0.000196   0.000005     call s:stop_region_update()
    1              0.000000   endif

FUNCTION  <SNR>84_add_didchange_queue()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp.vim:905
Called 2 times
Total time:   0.000042
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000002     if g:lsp_use_event_queue == 0
                                    for l:server_name in lsp#get_whitelisted_servers(a:buf)
                                        call s:ensure_flush(a:buf, l:server_name, function('s:Noop'))
                                    endfor
                                    return
    2              0.000001     endif
    2              0.000004     if index(s:didchange_queue, a:buf) != -1
    1              0.000001         return
    1              0.000000     endif
    1              0.000002     call add(s:didchange_queue, a:buf)
    1   0.000008   0.000004     call lsp#log('s:send_didchange_queue() will be triggered')
    1              0.000002     call timer_stop(s:didchange_timer)
    1              0.000002     let l:lazy = &updatetime > 1000 ? &updatetime : 1000
    1              0.000005     let s:didchange_timer = timer_start(l:lazy, function('s:send_didchange_queue'))

FUNCTION  dein#autoload#_source()
    Defined: ~/.cache/dein/repos/github.com/Shougo/dein.vim/autoload/dein/autoload.vim:7
Called 11 times
Total time:   0.000232
 Self time:   0.000167

count  total (s)   self (s)
   11   0.000203   0.000137   let plugins = empty(a:000) ? values(g:dein#_plugins) : dein#util#_convert2list(a:1)
   11              0.000014   if empty(plugins)
   11              0.000006     return
                              endif
                            
                              if type(plugins[0]) != v:t_dict
                                let plugins = map(dein#util#_convert2list(a:1),       'get(g:dein#_plugins, v:val, {})')
                              endif
                            
                              let rtps = dein#util#_split_rtp(&runtimepath)
                              let index = index(rtps, dein#util#_get_runtime_path())
                              if index < 0
                                return 1
                              endif
                            
                              let sourced = []
                              for plugin in filter(plugins, "!empty(v:val) && !v:val.sourced && v:val.rtp !=# ''")
                                call s:source_plugin(rtps, index, plugin, sourced)
                              endfor
                            
                              let filetype_before = dein#util#_redir('autocmd FileType')
                              let &runtimepath = dein#util#_join_rtp(rtps, &runtimepath, '')
                            
                              call dein#call_hook('source', sourced)
                            
                              " Reload script files.
                              for plugin in sourced
                                for directory in filter(['plugin', 'after/plugin'], "isdirectory(plugin.rtp.'/'.v:val)")
                                  for file in dein#util#_globlist(plugin.rtp.'/'.directory.'/**/*.vim')
                                    execute 'source' fnameescape(file)
                                  endfor
                                endfor
                            
                                if !has('vim_starting')
                                  let augroup = get(plugin, 'augroup', plugin.normalized_name)
                                  let events = ['VimEnter', 'BufRead', 'BufEnter', 'BufWinEnter', 'WinEnter']
                                  if has('gui_running') && &term ==# 'builtin_gui'
                                    call add(events, 'GUIEnter')
                                  endif
                                  for event in events
                                    if exists('#'.augroup.'#'.event)
                                      silent execute 'doautocmd' augroup event
                                    endif
                                  endfor
                                endif
                              endfor
                            
                              let filetype_after = dein#util#_redir('autocmd FileType')
                            
                              let is_reset = s:is_reset_ftplugin(sourced)
                              if is_reset
                                call s:reset_ftplugin()
                              endif
                            
                              if (is_reset || filetype_before !=# filetype_after) && &filetype !=# ''
                                " Recall FileType autocmd
                                let &filetype = &filetype
                              endif
                            
                              if !has('vim_starting')
                                call dein#call_hook('post_source', sourced)
                              endif

FUNCTION  lightline#statusline()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lightline.vim:307
Called 13 times
Total time:   0.012322
 Self time:   0.000232

count  total (s)   self (s)
   13              0.000025   if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
   13              0.000005   endif
   13   0.012266   0.000176   return s:line(0, a:inactive)

FUNCTION  dein#util#_convert2list()
    Defined: ~/.cache/dein/repos/github.com/Shougo/dein.vim/autoload/dein/util.vim:599
Called 11 times
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
   11              0.000061   return type(a:expr) ==# v:t_list ? copy(a:expr) : type(a:expr) ==# v:t_string ?   (a:expr ==# '' ? [] : split(a:expr, '\r\?\n', 1)) : [a:expr]

FUNCTION  <SNR>158_document_format()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/ui/vim.vim:209
Called 1 time
Total time:   0.000122
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000050   0.000009     let l:servers = filter(lsp#get_whitelisted_servers(), 'lsp#capabilities#has_document_formatting_provider(v:val)')
    1   0.000008   0.000005     let l:command_id = lsp#_new_command()
                            
    1              0.000002     if len(l:servers) == 0
    1   0.000060   0.000006         call s:not_supported('Document formatting')
    1              0.000001         return
                                endif
                            
                                " TODO: ask user to select server for formatting
                                let l:server = l:servers[0]
                                redraw | echo 'Formatting document ...'
                                call lsp#send_request(l:server, { 'method': 'textDocument/formatting', 'params': {   'textDocument': lsp#get_text_document_identifier(),   'options': {       'tabSize': getbufvar(bufnr('%'), '&tabstop'),       'insertSpaces': getbufvar(bufnr('%'), '&expandtab') ? v:true : v:false,   }, }, 'sync': a:sync, 'on_notification': function('s:handle_text_edit', [l:server, l:command_id, 'document format']), })

FUNCTION  <SNR>64_LocalBrowse()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/plugin/netrwPlugin.vim:102
Called 4 times
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    4              0.000008   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
    4              0.000001   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    4              0.000010   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    4              0.000053   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
    4              0.000002   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    4              0.000002   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  lsp#ui#vim#diagnostics#force_refresh()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/ui/vim/diagnostics.vim:25
Called 1 time
Total time:   0.000786
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000774   0.000008     let l:data = lsp#ui#vim#diagnostics#get_document_diagnostics(a:bufnr)
    1              0.000001     if !empty(l:data)
                                    for [l:server_name, l:response] in items(l:data)
                                        call lsp#ui#vim#virtual#set(l:server_name, l:response)
                                        call lsp#ui#vim#highlights#set(l:server_name, l:response)
                                        call lsp#ui#vim#diagnostics#textprop#set(l:server_name, l:response)
                                        call lsp#ui#vim#signs#set(l:server_name, l:response)
                                    endfor
    1              0.000000     endif

FUNCTION  lsp#_new_command()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp.vim:971
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002     let s:last_command_id += 1
    1              0.000001     return s:last_command_id

FUNCTION  fugitive#CommonDir()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:254
Called 288 times
Total time:   0.005476
 Self time:   0.005476

count  total (s)   self (s)
  288              0.000466   if empty(a:dir)
                                return ''
  288              0.000103   endif
  288              0.000588   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
  288              0.000086   endif
  288              0.000431   return s:commondirs[a:dir]

FUNCTION  neomru#_save()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:371
Called 1 time
Total time:   0.049894
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000007   let opts = a:0 >= 1 && type(a:1) == type({}) ? a:1 : {}
                            
    3              0.000009   for m in values(s:MRUs)
    2   0.049869   0.000018     call m.save(opts)
    3              0.000005   endfor

FUNCTION  <SNR>80_get_same_filetypes()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:468
Called 12 times
Total time:   0.000264
 Self time:   0.000264

count  total (s)   self (s)
   12              0.000189   let same_filetypes = extend(copy(s:default_same_filetypes), g:context_filetype#same_filetypes)
   12              0.000068   return split(get(same_filetypes, a:filetype, get(same_filetypes, '_', '')), ',')

FUNCTION  <SNR>105_is_directory_exist()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:421
Called 7 times
Total time:   0.000360
 Self time:   0.000360

count  total (s)   self (s)
    7              0.000242   let ignore = !empty(g:neomru#directory_mru_ignore_pattern) && a:path =~ g:neomru#directory_mru_ignore_pattern
    7              0.000108   return !ignore && (isdirectory(a:path) || a:path =~ '^\h\w\+:')

FUNCTION  indent_guides#exclude_filetype()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:279
Called 11 times
Total time:   0.000185
 Self time:   0.000185

count  total (s)   self (s)
   19              0.000089   for ft in split(&ft, '\.')
    8              0.000023     if index(g:indent_guides_exclude_filetypes, ft) > -1
                                  return 1
    8              0.000004     end
   19              0.000015   endfor
   11              0.000007   return 0

FUNCTION  lightline#mode()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lightline.vim:212
Called 96 times
Total time:   0.000365
 Self time:   0.000365

count  total (s)   self (s)
   96              0.000321   return get(s:lightline.mode_map, mode(), '')

FUNCTION  <SNR>16_denite_my_settings()
    Defined: ~/dotsfile/nvim/plugins/denite.vim:55
Called 3 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
    3              0.000074   nnoremap <silent><buffer><expr> <CR> denite#do_map('do_action')
    3              0.000024   nnoremap <silent><buffer><expr> D denite#do_map('do_action', 'delete')
    3              0.000019   nnoremap <silent><buffer><expr> p denite#do_map('do_action', 'preview')
    3              0.000022   nnoremap <silent><buffer><expr> <ESC><ESC> denite#do_map('quit')
    3              0.000018   nnoremap <silent><buffer><expr> i denite#do_map('open_filter_buffer')
    3              0.000018   nnoremap <silent><buffer><expr> <Space> denite#do_map('toggle_select').'j'
    3              0.000017   nnoremap <silent><buffer><expr> d denite#do_map('move_up_path')

FUNCTION  deoplete#custom#_get_filetype_option()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/custom.vim:87
Called 20 times
Total time:   0.000243
 Self time:   0.000243

count  total (s)   self (s)
   20              0.000043   let buffer_option = s:cached.buffer_option
   20              0.000035   if has_key(buffer_option, a:name)
                                " Use buffer_option instead
                                return buffer_option[a:name]
   20              0.000009   endif
                            
   20              0.000029   let option = s:cached.option[a:name]
   20              0.000041   let filetype = has_key(option, a:filetype) ? a:filetype : '_'
   20              0.000035   return get(option, filetype, a:default)

FUNCTION  <SNR>32_vim_lsp_suggest_plugin()
    Defined: ~/.cache/dein/repos/github.com/mattn/vim-lsp-settings/autoload/lsp_settings.vim:350
Called 1 time
Total time:   0.000787
 Self time:   0.000787

count  total (s)   self (s)
    1              0.000003   if &ft != ''
                                return
    1              0.000000   endif
    1              0.000004   let l:ext = expand('%:e')
   59              0.000058   for l:ft in keys(s:settings)
  134              0.000117     for l:server in s:settings[l:ft]
   76              0.000098       if !has_key(l:server, 'vim_plugin')
   62              0.000026         continue
   14              0.000005       endif
   14              0.000029       if index(l:server['vim_plugin']['extensions'], l:ext) == -1
   14              0.000006         continue
                                  endif
                                  redraw
                                  echohl Directory
                                  echomsg printf('Please install vim-plugin "%s" to enable Language Server', l:server['vim_plugin']['name'])
                                  echohl None
                                  return
   58              0.000020     endfor
   59              0.000021   endfor

FUNCTION  denite#helper#_start_update_candidates_timer()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/helper.vim:253
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015   return timer_start(100, {-> denite#call_async_map('update_candidates')}, {'repeat': -1})

FUNCTION  denite#start()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite.vim:10
Called 1 time
Total time:   0.140807
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000003   call inputsave()
    1              0.000001   try
    1              0.000004     let user_context = get(a:000, 0, {})
    1   0.140792   0.000024     return s:start(a:sources, user_context)
    1              0.000002   finally
    1              0.000003     call inputrestore()
    1              0.000001   endtry

FUNCTION  lsp#ui#vim#diagnostics#get_document_diagnostics()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/ui/vim/diagnostics.vim:37
Called 1 time
Total time:   0.000766
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000766   0.000007     return get(s:diagnostics, lsp#utils#get_buffer_uri(a:bufnr), {})

FUNCTION  <SNR>105_writefile()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:388
Called 4 times
Total time:   0.001561
 Self time:   0.001561

count  total (s)   self (s)
    4              0.000054   let path = fnamemodify(a:path, ':p')
    4              0.000034   if !isdirectory(fnamemodify(path, ':h'))
                                call mkdir(fnamemodify(path, ':h'), 'p')
    4              0.000002   endif
                            
    4              0.001456   call writefile(a:list, path)

FUNCTION  denite#helper#_parse_options_args()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/helper.vim:96
Called 1 time
Total time:   0.000905
 Self time:   0.000058

count  total (s)   self (s)
    1              0.000003   let _ = []
    1   0.000858   0.000012   let [args, options] = s:parse_options(a:cmdline)
                            
    2              0.000002   for arg in args
                                " Add source name.
    1              0.000007     let source_name = matchstr(arg, '^[^:]*')
    1              0.000003     let source_arg = arg[len(source_name)+1 :]
    1              0.000001     let source_args = []
    1              0.000001     if source_arg !=# ''
                                  for s in split(source_arg, s:re_unquoted_match('\\\@<!:'), 1)
                                    call add(source_args, s:remove_quote_pairs(s))
                                  endfor
    1              0.000000     endif
    1              0.000004     call add(_, { 'name': source_name, 'args': source_args })
    2              0.000002   endfor
                            
    1              0.000001   return [_, options]

FUNCTION  neomru#_append()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:321
Called 8 times
Total time:   0.091622
 Self time:   0.000225

count  total (s)   self (s)
    8              0.000076   if &l:buftype =~ 'help\|nofile' || &l:previewwindow
    1              0.000001     return
    7              0.000002   endif
    7   0.091529   0.000132   call neomru#append(s:expand('%:p'))

FUNCTION  denite#init#_initialize()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/init.vim:15
Called 1 time
Total time:   0.001238
 Self time:   0.000313

count  total (s)   self (s)
    1   0.000008   0.000005   if denite#init#_check_channel()
                                return
    1              0.000000   endif
                            
    1              0.000006   augroup denite
    1              0.000160     autocmd!
    1              0.000001   augroup END
                            
    1              0.000004   if !has('python3')
                                call denite#util#print_error( 'denite.nvim does not work with this version.')
                                call denite#util#print_error( 'It requires Neovim with Python3 support("+python3").')
                                return 1
    1              0.000000   endif
                            
    1              0.000004   if has('nvim') && !has('nvim-0.3.0')
                                call denite#util#print_error('denite.nvim requires nvim +v0.3.0.')
                                return 1
    1              0.000000   endif
    1              0.000002   if !has('nvim') && v:version < 800
                                call denite#util#print_error('denite.nvim requires Vim 8.0+.')
                                return 1
    1              0.000000   endif
                            
    1              0.000000   try
    1   0.000008   0.000005     if denite#util#has_yarp()
                                  let g:denite#_yarp = yarp#py3('denite')
                                  call g:denite#_yarp.request('_denite_init')
                                  let g:denite#_channel_id = 1
    1              0.000000     else
                                  " rplugin.vim may not be loaded on VimEnter
    1              0.000002       if !exists('g:loaded_remote_plugins')
                                    runtime! plugin/rplugin.vim
    1              0.000000       endif
    1   0.000975   0.000079       call _denite_init()
    1              0.000000     endif
    1   0.000031   0.000007     call s:initialize_variables()
                              catch
                                call denite#util#print_error(v:exception)
                                call denite#util#print_error(v:throwpoint)
                            
                                if denite#init#_msgpack_version_check()
                                  call denite#util#print_error('denite requires msgpack 1.0.0+.')
                                endif
                            
                                if denite#util#has_yarp()
                                  if !has('nvim') && !exists('*neovim_rpc#serveraddr')
                                    call denite#util#print_error( 'denite requires vim-hug-neovim-rpc plugin in Vim.')
                                  endif
                            
                                  if !exists('*yarp#py3')
                                    call denite#util#print_error( 'denite requires nvim-yarp plugin.')
                                  endif
                                else
                                  call denite#util#print_error( 'denite failed to load. ' .'Try the :UpdateRemotePlugins command and restart Neovim. ' .'See also :checkhealth.')
                                endif
                                return 1
    1              0.000001   endtry

FUNCTION  indent_guides#init_script_vars()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:184
Called 11 times
Total time:   0.001104
 Self time:   0.000651

count  total (s)   self (s)
   11              0.000018   if &l:shiftwidth > 0 && &l:expandtab
   11              0.000015     let s:indent_size = &l:shiftwidth
                              else
                                let s:indent_size = &l:tabstop
   11              0.000004   endif
   11   0.000152   0.000082   let s:guide_size  = indent_guides#calculate_guide_size()
   11   0.000466   0.000083   let s:hi_normal   = indent_guides#capture_highlight('Normal')
                            
                              " remove 'font=<value>' from the s:hi_normal string (only seems to happen on Vim startup in Windows)
   11              0.000102   let s:hi_normal = substitute(s:hi_normal, ' font=[A-Za-z0-9:]\+', "", "")
                            
                              " shortcuts to the global variables - this makes the code easier to read
   11              0.000014   let s:debug             = g:indent_guides_debug
   11              0.000013   let s:indent_levels     = g:indent_guides_indent_levels
   11              0.000012   let s:auto_colors       = g:indent_guides_auto_colors
   11              0.000018   let s:color_hex_pat     = g:indent_guides_color_hex_pattern
   11              0.000018   let s:color_hex_bg_pat  = g:indent_guides_color_hex_guibg_pattern
   11              0.000018   let s:color_name_bg_pat = g:indent_guides_color_name_guibg_pattern
   11              0.000013   let s:start_level       = g:indent_guides_start_level
                            
                              " str2float not available in vim versions <= 7.1
   11              0.000020   if has('float')
   11              0.000034     let s:change_percent = g:indent_guides_color_change_percent / str2float('100.0')
                              else
                                let s:change_percent = g:indent_guides_color_change_percent / 100.0
   11              0.000004   endif
                            
   11              0.000006   if s:debug
                                echo 's:indent_size = '       . s:indent_size
                                echo 's:guide_size = '        . s:guide_size
                                echo 's:hi_normal = '         . s:hi_normal
                                echo 's:indent_levels = '     . s:indent_levels
                                echo 's:auto_colors = '       . s:auto_colors
                                echo 's:change_percent = '    . string(s:change_percent)
                                echo 's:color_hex_pat = '     . s:color_hex_pat
                                echo 's:color_hex_bg_pat = '  . s:color_hex_bg_pat
                                echo 's:color_name_bg_pat = ' . s:color_name_bg_pat
                                echo 's:start_level = '       . s:start_level
   11              0.000004   endif

FUNCTION  fugitive#Head()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:495
Called 288 times
Total time:   0.101581
 Self time:   0.017174

count  total (s)   self (s)
  288   0.006810   0.001433   let dir = a:0 > 1 ? a:2 : s:Dir()
  288              0.000325   if empty(dir)
                                return ''
  288              0.000090   endif
  288   0.081062   0.002032   let file = fugitive#Find('.git/HEAD', dir)
  288              0.005104   let ftime = getftime(file)
  288              0.000351   if ftime == -1
                                return ''
  288              0.001065   elseif ftime != get(s:head_cache, dir, [-1])[0]
                                let s:head_cache[dir] = [ftime, readfile(file)[0]]
  288              0.000120   endif
  288              0.000523   let head = s:head_cache[dir][1]
  288              0.001460   if head =~# '^ref: '
  288              0.003368     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  denite#util#convert2list()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/util.vim:24
Called 3 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    3              0.000011   return type(a:expr) ==# v:t_list ? a:expr : [a:expr]

FUNCTION  <SNR>84_on_text_document_did_open()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp.vim:222
Called 1 time
Total time:   0.001605
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000003     let l:buf = bufnr('%')
    1              0.000004     if getbufvar(l:buf, '&buftype') ==# 'terminal' | return | endif
    1              0.000002     if getcmdwintype() !=# '' | return | endif
    1   0.000748   0.000035     call lsp#log('s:on_text_document_did_open()', l:buf, &filetype, getcwd(), lsp#utils#get_buffer_uri(l:buf))
                            
                                " Some language server notify diagnostics to the buffer that has not been loaded yet.
                                " This diagnostics was stored `autoload/lsp/ui/vim/diagnostics.vim` but not highlighted.
                                " So we should refresh highlights when buffer opened.
    1   0.000796   0.000010     call lsp#ui#vim#diagnostics#force_refresh(l:buf)
                            
    1   0.000044   0.000007     for l:server_name in lsp#get_whitelisted_servers(l:buf)
                                    call s:ensure_flush(l:buf, l:server_name, function('s:fire_lsp_buffer_enabled', [l:server_name, l:buf]))
    1              0.000001     endfor

FUNCTION  deoplete#send_event()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete.vim:43
Called 6 times
Total time:   0.000603
 Self time:   0.000152

count  total (s)   self (s)
    6   0.000115   0.000088   let sources = deoplete#util#convert2list(get(a:000, 0, []))
    6   0.000481   0.000057   call deoplete#util#rpcnotify('deoplete_on_event', {'event': a:event, 'sources': sources})

FUNCTION  _denite_init()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/autoload/remote/define.vim:169
Called 1 time
Total time:   0.000467
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000466   0.000008 return remote#define#request(3, "/Users/roy/.cache/dein/.cache/init.vim/.dein/rplugin/python3/denite:function:_denite_init", a:000)

FUNCTION  <SNR>79_recover_filetype()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious/switcher/setfiletype.vim:27
Called 3 times
Total time:   0.001168
 Self time:   0.000030

count  total (s)   self (s)
    3   0.001167   0.000029 	call precious#autocmd_switch(precious#context_filetype())

FUNCTION  fugitive#head()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:6303
Called 288 times
Total time:   0.111623
 Self time:   0.003970

count  total (s)   self (s)
  288   0.007720   0.001648   if empty(s:Dir())
                                return ''
  288              0.000093   endif
                            
  288   0.103389   0.001808   return fugitive#Head(a:0 ? a:1 : 0)

FUNCTION  context_filetype#get_filetypes()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:42
Called 8 times
Total time:   0.003500
 Self time:   0.000389

count  total (s)   self (s)
    8   0.002989   0.000062   let filetype = call('context_filetype#get_filetype', a:000)
                            
    8              0.000012   let filetypes = [filetype]
    8              0.000023   if filetype =~ '\.'
                                if has_key(g:context_filetype#ignore_composite_filetypes, filetype)
                                  let filetypes = [g:context_filetype#ignore_composite_filetypes[filetype]]
                                else
                                  " Set composite filetype.
                                  let filetypes += split(filetype, '\.')
                                endif
    8              0.000003   endif
                            
   16              0.000030   for ft in copy(filetypes)
    8   0.000313   0.000130     let filetypes += s:get_same_filetypes(ft)
   16              0.000013   endfor
                            
    8              0.000012   if len(filetypes) > 1
                                let filetypes = s:uniq(filetypes)
    8              0.000003   endif
                            
    8              0.000006   return filetypes

FUNCTION  <SNR>160_TraverseAncestorDirSearch()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/executable.vim:41
Called 1 time
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
    1              0.000001   let l:root = a:rootDir
    1              0.000001   let l:dir = 'node_modules'
                            
    9              0.000004   while 1
    9              0.000017     let l:searchDir = l:root . '/' . l:dir
    9              0.000050     if isdirectory(l:searchDir)
                                  return l:searchDir
    9              0.000004     endif
                            
    9              0.000019     let l:parent = fnamemodify(l:root, ':h')
    9              0.000011     if l:parent == l:root
    1              0.000001       return -1
    8              0.000002     endif
                            
    8              0.000007     let l:root = l:parent
    8              0.000004   endwhile

FUNCTION  precious#set_base_filetype()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious.vim:6
Called 5 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    5              0.000009 	let b:precious_base_filetype = a:filetype

FUNCTION  32()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:135
Called 16 times
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
   16              0.000215   return self.mtime < getftime(self.mru_file)

FUNCTION  context_filetype#get_same_filetypes()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:67
Called 4 times
Total time:   0.003511
 Self time:   0.000202

count  total (s)   self (s)
    4   0.001566   0.000037   let filetype = call('context_filetype#get_filetype', a:000)
                            
    4              0.000004   let filetypes = []
    8   0.001733   0.000035   for ft in context_filetype#get_filetypes(filetype)
    4   0.000170   0.000089     let filetypes += s:get_same_filetypes(ft)
    8              0.000006   endfor
                            
    4              0.000005   if len(filetypes) > 1
                                let filetypes = s:uniq(filetypes)
    4              0.000002   endif
                            
    4              0.000003   return filetypes

FUNCTION  38()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:266
Called 3 times
Total time:   0.104895
 Self time:   0.012940

count  total (s)   self (s)
    3              0.000004   if self.do_validate
    3   0.104883   0.012927     call filter(self.candidates, 's:is_file_exist(v:val)')
    3              0.000004   endif

FUNCTION  deoplete#custom#_get_option()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/custom.vim:84
Called 22 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
   22              0.000074   return s:cached.option[a:name]

FUNCTION  remote#define#request()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/autoload/remote/define.vim:194
Called 1 time
Total time:   0.000459
 Self time:   0.000459

count  total (s)   self (s)
    1              0.000004   let s:busy[a:chan] = get(s:busy, a:chan, 0)+1
    1              0.000439   let val = call('rpcrequest', [a:chan]+a:000)
    1              0.000003   let s:busy[a:chan] -= 1
    1              0.000001   if s:busy[a:chan] == 0
    1              0.000003     for msg in get(s:pending_notifications, a:chan, [])
                                  call call('rpcnotify', [a:chan] + msg)
    1              0.000001     endfor
    1              0.000004     let s:pending_notifications[a:chan] = []
    1              0.000000   endif
    1              0.000001   return val

FUNCTION  lsp#utils#path_to_uri()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/utils.vim:60
Called 2 times
Total time:   0.001396
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000005         if empty(a:path)
                                        return a:path
    2              0.000001         else
    2   0.001387   0.000015             return s:encode_uri(a:path, 0, 'file://')
                                    endif

FUNCTION  <SNR>98_on_cursor_moved()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/ui/vim/signature_help.vim:115
Called 11 times
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
   11              0.000028     let l:bufnr = bufnr('%')
   11              0.000025     call timer_stop(s:debounce_timer_id)
   11              0.000086     let s:debounce_timer_id = timer_start(500, function('s:on_text_changed_after', [l:bufnr]), { 'repeat': 1 })

FUNCTION  LightlineFilename()
    Defined: ~/dotsfile/nvim/plugins/lightline.vim:19
Called 99 times
Total time:   0.005214
 Self time:   0.005214

count  total (s)   self (s)
   99              0.000428   let root = fnamemodify(get(b:, 'git_dir'), ':h')
   99              0.004139   let path = expand('%:p')
   99              0.000355   if path[:len(root)-1] ==# root
   99              0.000188     return path[len(root)+1:]
                              endif
                              return expand('%')

FUNCTION  prettier#resolver#preset#resolve()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/preset.vim:2
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000003   if ( g:prettier#preset#config ==# 'fb' )
                                return extend(prettier#presets#fb#config(), a:fileTypeConfigOverwrites)
    1              0.000001   endif
                            
    1              0.000001   return a:fileTypeConfigOverwrites

FUNCTION  indent_guides#init_matches()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:176
Called 11 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
   11              0.000040   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []

FUNCTION  fugitive#ReloadStatus()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:2862
Called 1 time
Total time:   0.000174
 Self time:   0.000032

count  total (s)   self (s)
    1   0.000146   0.000008   call s:ExpireStatus(a:0 ? a:1 : -1)
    1              0.000001   if a:0 > 1 ? a:2 : 1
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
                                exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
    1              0.000000   else
    1   0.000011   0.000007     call s:ReloadWinStatus()
    1              0.000000   endif
    1              0.000000   return ''

FUNCTION  deoplete#custom#_get_buffer()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/custom.vim:67
Called 5 times
Total time:   0.000042
 Self time:   0.000037

count  total (s)   self (s)
    5              0.000012   if !exists('b:custom')
    1   0.000010   0.000005     call deoplete#custom#_init_buffer()
    5              0.000002   endif
                            
    5              0.000005   return b:custom

FUNCTION  <SNR>85_ReloadWinStatus()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:2823
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
    1              0.000000     return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif

FUNCTION  <SNR>118_MarkdownRefreshSyntax()
    Defined: ~/.cache/dein/repos/github.com/plasticboy/vim-markdown/ftplugin/markdown.vim:770
Called 3 times
Total time:   0.000765
 Self time:   0.000105

count  total (s)   self (s)
    3              0.000019     if &filetype =~ 'markdown' && line('$') > 1
    3   0.000740   0.000080         call s:MarkdownHighlightSources(a:force)
    3              0.000001     endif

FUNCTION  <SNR>105_fnamemodify()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:22
Called 14 times
Total time:   0.000387
 Self time:   0.000336

count  total (s)   self (s)
   14   0.000379   0.000329   return s:substitute_path_separator(fnamemodify(a:fname, a:mods))

FUNCTION  precious#reset_contextlocal()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious.vim:140
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000002 	if exists("b:precious_option_backup")
                            		for [option, old] in items(b:precious_option_backup)
                            			execute "let &".option."=old"
                            		endfor
    1              0.000000 	endif
    1              0.000001 	let b:precious_option_backup = {}

FUNCTION  <SNR>118_MarkdownClearSyntaxVariables()
    Defined: ~/.cache/dein/repos/github.com/plasticboy/vim-markdown/ftplugin/markdown.vim:776
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000007     if &filetype =~ 'markdown'
    1              0.000005         unlet! b:mkd_included_filetypes
    1              0.000001     endif

FUNCTION  <SNR>83_subseparator()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lightline.vim:294
Called 48 times
Total time:   0.001942
 Self time:   0.001942

count  total (s)   self (s)
   48              0.000243   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
   48              0.001264   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
   48              0.000401   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  defx#init#_check_channel()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/defx/init.vim:78
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000009   return exists('g:defx#_channel_id')

FUNCTION  deoplete#util#rpcnotify()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/util.vim:155
Called 6 times
Total time:   0.000424
 Self time:   0.000296

count  total (s)   self (s)
    6   0.000055   0.000036   if !deoplete#init#_channel_initialized()
                                return ''
    6              0.000002   endif
                            
    6              0.000013   let a:context['rpc'] = a:method
                            
    6   0.000180   0.000071   if deoplete#util#has_yarp()
                                if g:deoplete#_yarp.job_is_dead
                                  return ''
                                endif
                                call g:deoplete#_yarp.notify(a:method, a:context)
    6              0.000003   else
    6              0.000119     call rpcnotify(g:deoplete#_channel_id, a:method, a:context)
    6              0.000003   endif
                            
    6              0.000004   return ''

FUNCTION  <SNR>80_get_nest_impl()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:632
Called 38 times
Total time:   0.003991
 Self time:   0.000545

count  total (s)   self (s)
   38   0.003766   0.000320   let context = s:get_context(a:filetype, a:context_filetypes, a:prev_context.range)
   38              0.000065   if context.range != s:null_range && context.filetype !=# a:filetype
                                return s:get_nest_impl(context.filetype, a:context_filetypes, context)
   38              0.000020   else
   38              0.000031     return a:prev_context
                              endif

FUNCTION  precious#switch_def()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious.vim:68
Called 18 times
Total time:   0.000527
 Self time:   0.000527

count  total (s)   self (s)
   18              0.000054 	let fallback = get(a:, 1, 0)
   18              0.000021 	let NOTDEF = {}
   18              0.000041 	let ft_def = get(a:defs, a:name, NOTDEF)
                            
   18              0.000018 	if ft_def is NOTDEF
   18              0.000038 		if exists("*glob2regpat")
   18              0.000090 			let matches = filter(copy(a:defs), "v:key != '*' && v:key =~ '[*?\\[]'" . " && match(a:name, glob2regpat(v:key)) != -1")
   18              0.000025 			if !empty(matches)
                            				unlet ft_def
                            				let ft_def = sort( map(items(matches), "[strlen(v:val[0]), v:val[1]]"), "s:compare")[0][1]
   18              0.000008 			endif
   18              0.000007 		endif
                            
   18              0.000015 		if ft_def is NOTDEF
   18              0.000016 			unlet ft_def
   18              0.000040 			let ft_def = get(a:defs, "*", fallback)
   18              0.000007 		endif
   18              0.000006 	endif
                            
   18              0.000013 	return ft_def

FUNCTION  <SNR>85_cpath()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:125
Called 1 time
Total time:   0.000043
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000014   0.000007   if s:FileIgnoreCase(0)
                                let path = FugitiveVimPath(tolower(a:path))
    1              0.000001   else
    1   0.000022   0.000007     let path = FugitiveVimPath(a:path)
    1              0.000000   endif
    1              0.000002   return a:0 ? path ==# s:cpath(a:1) : path

FUNCTION  indent_guides#indent_highlight_pattern()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:269
Called 638 times
Total time:   0.004954
 Self time:   0.004954

count  total (s)   self (s)
  638              0.001644   let l:pattern  = '^' . a:indent_pattern . '*\%' . a:column_start . 'v\zs'
  638              0.001657   let l:pattern .= a:indent_pattern . '*\%' . (a:column_start + a:indent_size) . 'v'
  638              0.000758   let l:pattern .= '\ze'
  638              0.000475   return l:pattern

FUNCTION  denite#util#rpcrequest()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/util.vim:240
Called 4 times
Total time:   0.155283
 Self time:   0.103032

count  total (s)   self (s)
    4   0.000037   0.000023   if !denite#init#_check_channel()
                                return -1
    4              0.000002   endif
                            
    4   0.000030   0.000017   if denite#util#has_yarp()
                                if g:denite#_yarp.job_is_dead
                                  return -1
                                endif
                                if a:is_async
                                  return g:denite#_yarp.notify(a:method, a:args)
                                else
                                  return g:denite#_yarp.request(a:method, a:args)
                                endif
    4              0.000002   else
    4              0.000003     if a:is_async
    1              0.000015       return rpcnotify(g:denite#_channel_id, a:method, a:args)
    3              0.000001     else
    3   0.155149   0.102924       return rpcrequest(g:denite#_channel_id, a:method, a:args)
                                endif
                              endif

FUNCTION  <SNR>80_search_range()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:520
Called 34 times
Total time:   0.003393
 Self time:   0.002964

count  total (s)   self (s)
   34   0.000461   0.000243   let stopline_forward = s:stopline_forward()
   34   0.000368   0.000215   let stopline_back    = s:stopline_back()
                            
   34              0.000532   let cur_text = (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode() ==# 'i' ? col('.') : col('.') - 1)         . 'c' . (mode() ==# 'i' ? '' : '.'))
   34              0.000107   let curline_pattern = a:start_pattern . '\ze.\{-}$'
   34              0.000208   if cur_text =~# curline_pattern
                                let start = [line('.'), matchend(cur_text, curline_pattern)]
   34              0.000019   else
   34              0.000547     let start = searchpos(a:start_pattern, 'bnceW', stopline_back)
   34              0.000018   endif
   34              0.000043   if start == s:null_pos
   17              0.000015     return s:null_range
   17              0.000007   endif
   17              0.000026   let start[1] += 1
                            
   17              0.000049   let end_pattern = a:end_pattern
   17              0.000066   if end_pattern =~# '\\\d\+'
                                let lines = getline(start[0], line('.'))
                                let match_list = matchlist(join(lines, "\n"), a:start_pattern)
                                let end_pattern = s:replace_submatch(end_pattern, match_list)
   17              0.000007   endif
                            
   17              0.000121   let end_forward = searchpos(end_pattern, 'ncW', stopline_forward)
   17              0.000019   if end_forward == s:null_pos
   17              0.000072     let end_forward = [line('$'), len(getline('$'))+1]
   17              0.000008   endi
                            
   17              0.000147   let end_backward = searchpos(end_pattern, 'bnW', stopline_back)
   17   0.000211   0.000153   if s:pos_less_equal(start, end_backward)
   17              0.000016     return s:null_range
                              endif
                              let end_forward[1] -= 1
                            
                              if mode() !=# 'i' && start[1] >= strdisplaywidth(getline(start[0]))
                                let start[0] += 1
                                let start[1] = 1
                              endif
                            
                              if end_forward[1] <= 1
                                let end_forward[0] -= 1
                                let len = len(getline(end_forward[0]))
                                let len = len ? len : 1
                                let end_forward[1] = len
                              endif
                            
                              return [start, end_forward]

FUNCTION  denite#helper#call_denite()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/helper.vim:35
Called 1 time
Total time:   0.142292
 Self time:   0.000258

count  total (s)   self (s)
    1   0.000936   0.000031   let [args, context] = denite#helper#_parse_options_args(a:args)
                            
    1              0.000002   let context.command = a:command
    1              0.000001   let context.firstline = a:line1
    1              0.000001   let context.lastline = a:line2
                            
    1   0.141349   0.000220   call denite#start(args, context)

FUNCTION  <SNR>105_is_sudo()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:451
Called 4 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    4              0.000025   return $SUDO_USER != '' && $USER !=# $SUDO_USER && $HOME !=# expand('~'.$USER) && $HOME ==# expand('~'.$SUDO_USER)

FUNCTION  prettier#utils#shim#shiftwidth()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/utils/shim.vim:2
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004   if exists('*shiftwidth')
    1              0.000002     return shiftwidth()
                              else
                                return &shiftwidth
                              endif

FUNCTION  context_filetype#version()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:21
Called 23 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
   23              0.000087   return str2nr(printf('%02d%02d', 1, 0))

FUNCTION  fugitive#Find()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:918
Called 288 times
Total time:   0.079030
 Self time:   0.052133

count  total (s)   self (s)
  288              0.000637   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
  288              0.001266   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
  288   0.005639   0.004233   elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
  288   0.003569   0.002384   elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
  288              0.000109   endif
  288              0.000593   let dir = a:0 ? a:1 : s:Dir()
  288              0.000352   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
  288              0.000083   endif
  288   0.002774   0.001577   let rev = s:Slash(a:object)
  288   0.017555   0.001434   let tree = s:Tree(dir)
  288              0.000637   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
  288              0.000283   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
  288              0.000918   elseif rev =~# '^\.git/'
  288              0.001443     let f = substitute(rev, '^\.git', '', '')
  288   0.007406   0.001930     let cdir = fugitive#CommonDir(dir)
  288              0.001073     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
  288              0.000871     elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
  288              0.001266     elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
  288              0.000116     else
  288              0.000770       let f = simplify(dir . f)
  288              0.000115     endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
  288              0.000098   endif
  288   0.003242   0.001731   return FugitiveVimPath(f)

FUNCTION  <SNR>83_expand()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lightline.vim:369
Called 26 times
Total time:   0.005439
 Self time:   0.003832

count  total (s)   self (s)
   26              0.000029   let components = []
   26              0.000025   let expanded = []
   26              0.000020   let indices = []
   26              0.000019   let prevtype = ''
   26              0.000022   let previndex = -1
   26   0.002522   0.000915   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
  121              0.000163   for [component, expand, type, index] in xs
   95              0.000103     if prevtype !=# type
   47              0.000173       for i in range(previndex + 1, max([previndex, index - 1]))
                                    call add(indices, string(i))
                                    call add(components, [])
                                    call add(expanded, [])
   47              0.000021       endfor
   47              0.000075       call add(indices, type)
   47              0.000060       call add(components, [])
   47              0.000054       call add(expanded, [])
   95              0.000047     endif
   95              0.000164     call extend(components[-1], component)
   95              0.000315     call extend(expanded[-1], repeat([expand], len(component)))
   95              0.000090     let prevtype = type
   95              0.000080     let previndex = index
  121              0.000080   endfor
   26              0.000109   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
                                call add(indices, string(i))
                                call add(components, [])
                                call add(expanded, [])
   26              0.000020   endfor
   26              0.000081   call add(indices, string(len(a:components)))
   26              0.000038   return [components, expanded, indices]

FUNCTION  <SNR>85_ExpireStatus()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:2807
Called 1 time
Total time:   0.000138
 Self time:   0.000063

count  total (s)   self (s)
    1              0.000001   if a:bufnr == -2
                                let s:head_cache = {}
                                let s:last_time = reltime()
                                return ''
    1              0.000001   endif
    1   0.000049   0.000016   let dir = s:Dir(a:bufnr)
    1              0.000002   if len(dir)
    1   0.000056   0.000014     let s:last_times[s:cpath(dir)] = reltime()
    1              0.000006     if has_key(s:head_cache, dir)
    1              0.000016       call remove(s:head_cache, dir)
    1              0.000000     endif
    1              0.000000   endif
    1              0.000001   return ''

FUNCTION  <SNR>165_asyncFormat()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/job/runner.vim:22
Called 1 time
Total time:   0.002024
 Self time:   0.000221

count  total (s)   self (s)
    1              0.000001     if !s:isAsyncVim && !s:isNeoVim 
                                  call s:format(a:cmd, a:startSelection, a:endSelection)
    1              0.000001     endif 
                            
                                " required for Windows support on async operations 
    1              0.000002     let l:cmd = a:cmd
    1              0.000004     if has('win32') || has('win64')
                                  let l:cmd = 'cmd.exe /c ' . a:cmd
    1              0.000000     endif
                            
    1              0.000001     if s:isAsyncVim
                                  call prettier#job#async#vim#run(l:cmd, a:startSelection, a:endSelection)
    1              0.000000     else
    1   0.002005   0.000202       call prettier#job#async#neovim#run(l:cmd, a:startSelection, a:endSelection)
    1              0.000001     endif

FUNCTION  <SNR>84_on_text_document_did_save()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp.vim:242
Called 1 time
Total time:   0.000103
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000006     let l:buf = bufnr('%')
    1              0.000006     if getbufvar(l:buf, '&buftype') ==# 'terminal' | return | endif
    1   0.000018   0.000006     call lsp#log('s:on_text_document_did_save()', l:buf)
    1   0.000057   0.000009     for l:server_name in lsp#get_whitelisted_servers(l:buf)
                                    if g:lsp_text_document_did_save_delay >= 0
                                        " We delay the callback by one loop iteration as calls to ensure_flush
                                        " can introduce mmap'd file locks that linger on Windows and collide
                                        " with the second lang server call preventing saves (see #455)
                                        call s:ensure_flush(l:buf, l:server_name, {result->timer_start(g:lsp_text_document_did_save_delay, {timer->s:call_did_save(l:buf, l:server_name, result, function('s:Noop'))})})
                                    else
                                        call s:ensure_flush(l:buf, l:server_name, {result->s:call_did_save(l:buf, l:server_name, result, function('s:Noop'))})
                                    endif
    1              0.000001     endfor

FUNCTION  color_helper#hex_to_dec()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/color_helper.vim:29
Called 66 times
Total time:   0.000265
 Self time:   0.000265

count  total (s)   self (s)
   66              0.000241   return (a:arg =~? '^0x') ? a:arg + 0 : ('0x'.a:arg) + 0

FUNCTION  color_helper#dec_to_hex()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/color_helper.vim:13
Called 66 times
Total time:   0.000245
 Self time:   0.000245

count  total (s)   self (s)
   66              0.000225   return toupper(printf('%0' . a:padding . 'x', a:arg + 0))

FUNCTION  <SNR>68_GetFunctionPrefix()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/autoload/remote/define.vim:250
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002   let res = "function! ".a:name."(...)"
    1              0.000001   if has_key(a:opts, 'range')
                                let res = res." range"
    1              0.000000   endif
    1              0.000001   return res."\n"

FUNCTION  <SNR>81_setup_if_required()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/asyncomplete.vim:32
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000002     if !s:already_setup
                                    " register asyncomplete change manager
                                    for l:change_manager in g:asyncomplete_change_manager
                                        call asyncomplete#log('core', 'initializing asyncomplete change manager', l:change_manager)
                                        if type(l:change_manager) == type('')
                                            execute 'let s:on_change_manager = function("'. l:change_manager  .'")()'
                                        else
                                            let s:on_change_manager = l:change_manager()
                                        endif
                                        if has_key(s:on_change_manager, 'error')
                                            call asyncomplete#log('core', 'initializing asyncomplete change manager failed', s:on_change_manager['name'], s:on_change_manager['error'])
                                        else
                                            call s:on_change_manager.register(function('s:on_change'))
                                            call asyncomplete#log('core', 'initializing asyncomplete change manager complete', s:on_change_manager['name'])
                                            break
                                        endif
                                    endfor
                            
                                    augroup asyncomplete
                                        autocmd!
                                        autocmd InsertEnter * call s:on_insert_enter()
                                        autocmd InsertLeave * call s:on_insert_leave()
                                    augroup END
                            
                                    doautocmd User asyncomplete_setup
                                    let s:already_setup = 1
    1              0.000000     endif

FUNCTION  indent_guides#clear_matches()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:75
Called 11 times
Total time:   0.003748
 Self time:   0.003704

count  total (s)   self (s)
   11   0.000102   0.000058   call indent_guides#init_matches()
   11              0.000018   if !empty(w:indent_guides_matches)
   10              0.000010     let l:index = 0
  590              0.000326     for l:match_id in w:indent_guides_matches
  580              0.000206       try
  580              0.000830         call matchdelete(l:match_id)
                                  catch /E803:/
                                    " Do nothing
  580              0.000207       endtry
  580              0.000782       call remove(w:indent_guides_matches, l:index)
  580              0.000470       let l:index += l:index
  590              0.000218     endfor
   11              0.000005   endif

FUNCTION  <SNR>80_pos_less_equal()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:489
Called 17 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
   17              0.000050   return a:a[0] == a:b[0] ? a:a[1] <= a:b[1] : a:a[0] <= a:b[0]

FUNCTION  asyncomplete#enable_for_buffer()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/asyncomplete.vim:62
Called 1 time
Total time:   0.000051
 Self time:   0.000023

count  total (s)   self (s)
    1   0.000049   0.000022     call s:setup_if_required()
    1              0.000001     let b:asyncomplete_enable = 1

FUNCTION  <SNR>105_is_file_exist()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:414
Called 1861 times
Total time:   0.092515
 Self time:   0.092515

count  total (s)   self (s)
 1861              0.069748   let ignore = !empty(g:neomru#file_mru_ignore_pattern) && a:path =~ g:neomru#file_mru_ignore_pattern
 1861              0.021797   return !ignore && (getftype(a:path) ==# 'file' || getftype(a:path) ==# 'link' || a:path =~ '^\h\w\+:')

FUNCTION  <SNR>162_Flag_use_tabs()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/config.vim:61
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000005   let l:value = get(a:config, 'useTabs', g:prettier#config#use_tabs)
    1              0.000002   if (l:value ==# 'auto')
    1              0.000002     let l:value = &expandtab ? 'false' : 'true'
    1              0.000001   endif
                            
    1              0.000001   if ( l:value ==# 'true' )
                                return ' --use-tabs'
    1              0.000001   else
    1              0.000001     return ''
                              endif

FUNCTION  deoplete#custom#_update_cache()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/custom.vim:27
Called 5 times
Total time:   0.000484
 Self time:   0.000442

count  total (s)   self (s)
    5              0.000025   if !exists('s:custom')
                                call deoplete#custom#_init()
    5              0.000003   endif
                            
    5   0.000081   0.000038   let custom_buffer = deoplete#custom#_get_buffer()
                            
    5              0.000104   let s:cached.option = copy(s:custom.option)
    5              0.000017   let s:cached.buffer_option = copy(custom_buffer.option)
    5              0.000018   call extend(s:cached.option, s:cached.buffer_option)
                            
    5              0.000015   let s:cached.source_vars = {}
   15              0.000041   for [name, source] in items(s:custom.source)
   10              0.000034     let s:cached.source_vars[name] = get(source, 'vars', {})
   15              0.000011   endfor
    5              0.000011   for [name, vars] in items(custom_buffer.source_vars)
                                if !has_key(s:cached.source_vars, name)
                                  let s:cached.source_vars[name] = {}
                                endif
                                call extend(s:cached.source_vars[name], vars)
    5              0.000005   endfor
    5              0.000006   let s:cached.filter = {}
    5              0.000009   for [name, vars] in items(s:custom.filter)
                                let s:cached.filter[name] = vars
    5              0.000003   endfor
    5              0.000009   for [name, vars] in items(custom_buffer.filter)
                                if !has_key(s:cached.filter, name)
                                  let s:cached.filter[name] = {}
                                endif
                                call extend(s:cached.filter[name], vars)
    5              0.000004   endfor

FUNCTION  <SNR>105_uniq()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:396
Called 4 times
Total time:   0.027344
 Self time:   0.000329

count  total (s)   self (s)
    4   0.027342   0.000328   return s:uniq_by(a:list, 'tolower(v:val)')

FUNCTION  defx#redraw()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/defx.vim:60
Called 2 times
Total time:   0.001772
 Self time:   0.000034

count  total (s)   self (s)
    2   0.001769   0.000031   call defx#util#rpcrequest('_defx_redraw', [], v:false)

FUNCTION  <SNR>68_GetRpcFunction()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/autoload/remote/define.vim:175
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000001   if a:sync ==# 'urgent'
                                return 'rpcnotify'
    1              0.000001   elseif a:sync
    1              0.000001     return 'remote#define#request'
                              endif
                              return 'remote#define#notify'

FUNCTION  <SNR>83_convert()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lightline.vim:336
Called 95 times
Total time:   0.001146
 Self time:   0.001146

count  total (s)   self (s)
   95              0.000168   if has_key(s:lightline.component_expand, a:name)
                                let type = get(s:lightline.component_type, a:name, a:index)
                                let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
                                return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
   95              0.000043   else
   95              0.000195     return [[[a:name], 0, a:index, a:index]]
                              endif

FUNCTION  denite#helper#_set_available_sources()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/helper.vim:220
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                              " Called from rplugin/python3/denite/denite.py#load_sources
    1              0.000007   let s:source_names = a:source_names

FUNCTION  denite#filter#_close_filter_window()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/filter.vim:234
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000006   if !exists('g:denite#_filter_winid') || g:denite#_filter_winid < 0 || win_id2win(g:denite#_filter_winid) <= 0
    1              0.000001     return
                              endif
                            
                              let prev = win_getid()
                            
                              call win_gotoid(g:denite#_filter_winid)
                              close!
                            
                              call win_gotoid(prev)

FUNCTION  <SNR>53_append()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/neomru.vim:32
Called 8 times
Total time:   0.091788
 Self time:   0.000165

count  total (s)   self (s)
    8              0.000056   if bufnr('%') != expand('<abuf>') || a:path == ''
                                return
    8              0.000004   endif
                            
    8   0.091707   0.000084   call neomru#_append()

FUNCTION  indent_guides#calculate_guide_size()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:232
Called 11 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
   11              0.000017   let l:guide_size = g:indent_guides_guide_size
                            
   11              0.000017   if l:guide_size == 0 || l:guide_size > s:indent_size
                                let l:guide_size = s:indent_size
   11              0.000004   endif
                            
   11              0.000008   return l:guide_size

FUNCTION  deoplete#init#_channel_initialized()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/deoplete/init.vim:97
Called 6 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    6              0.000015   return get(g:, 'deoplete#_initialized', v:false)

FUNCTION  indent_guides#capture_highlight()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:248
Called 11 times
Total time:   0.000383
 Self time:   0.000383

count  total (s)   self (s)
   11              0.000024   redir => l:output
   11              0.000252   exe "silent hi " . a:group_name
   11              0.000025   redir END
                            
   11              0.000060   let l:output = substitute(l:output, "\n", "", "")
   11              0.000010   return l:output

FUNCTION  <SNR>35_encode_uri()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/utils.vim:22
Called 2 times
Total time:   0.001373
 Self time:   0.001285

count  total (s)   self (s)
    2   0.000089   0.000016     let l:prefix = s:get_prefix(a:path)
    2              0.000011     let l:path = a:path[len(l:prefix):]
    2              0.000006     if len(l:prefix) == 0
    2              0.000019         let l:prefix = a:default_prefix
    2              0.000001     endif
                            
    2              0.000005     let l:result = strpart(a:path, 0, a:start_pos_encode)
                            
  156              0.000101     for l:i in range(a:start_pos_encode, len(l:path) - 1)
                                    " Don't encode '/' here, `path` is expected to be a valid path.
  154              0.000446         if l:path[l:i] =~# '^[a-zA-Z0-9_.~/-]$'
  150              0.000221             let l:result .= l:path[l:i]
    4              0.000001         else
    4   0.000040   0.000026             let l:result .= s:urlencode_char(l:path[l:i])
  154              0.000052         endif
  156              0.000052     endfor
                            
    2              0.000003     return l:prefix . l:result

FUNCTION  <SNR>118_MarkdownHighlightSources()
    Defined: ~/.cache/dein/repos/github.com/plasticboy/vim-markdown/ftplugin/markdown.vim:700
Called 3 times
Total time:   0.000660
 Self time:   0.000660

count  total (s)   self (s)
                                " Syntax highlight source code embedded in notes.
                                " Look for code blocks in the current file
    3              0.000007     let filetypes = {}
   54              0.000106     for line in getline(1, '$')
   51              0.000231         let ft = matchstr(line, '```\s*\zs[0-9A-Za-z_+-]*')
  102              0.000103         if !empty(ft) && ft !~ '^\d*$' | let filetypes[ft] = 1 | endif
   54              0.000022     endfor
    3              0.000009     if !exists('b:mkd_known_filetypes')
                                    let b:mkd_known_filetypes = {}
    3              0.000001     endif
    3              0.000005     if !exists('b:mkd_included_filetypes')
                                    " set syntax file name included
                                    let b:mkd_included_filetypes = {}
    3              0.000001     endif
    3              0.000008     if !a:force && (b:mkd_known_filetypes == filetypes || empty(filetypes))
    2              0.000001         return
    1              0.000000     endif
                            
                                " Now we're ready to actually highlight the code blocks.
    1              0.000001     let startgroup = 'mkdCodeStart'
    1              0.000001     let endgroup = 'mkdCodeEnd'
    2              0.000003     for ft in keys(filetypes)
    1              0.000002         if a:force || !has_key(b:mkd_known_filetypes, ft)
    1              0.000002             if has_key(s:filetype_dict, ft)
                                            let filetype = s:filetype_dict[ft]
    1              0.000001             else
    1              0.000001                 let filetype = ft
    1              0.000000             endif
    1              0.000007             let group = 'mkdSnippet' . toupper(substitute(filetype, "[+-]", "_", "g"))
    1              0.000002             if !has_key(b:mkd_included_filetypes, filetype)
                                            let include = s:SyntaxInclude(filetype)
                                            let b:mkd_included_filetypes[filetype] = 1
    1              0.000000             else
    1              0.000002                 let include = '@' . toupper(filetype)
    1              0.000000             endif
    1              0.000002             let command = 'syntax region %s matchgroup=%s start="^\s*```\s*%s$" matchgroup=%s end="\s*```$" keepend contains=%s%s'
    1              0.000032             execute printf(command, group, startgroup, ft, endgroup, include, has('conceal') && get(g:, 'vim_markdown_conceal', 1) && get(g:, 'vim_markdown_conceal_code_blocks', 1) ? ' concealends' : '')
    1              0.000009             execute printf('syntax cluster mkdNonListItem add=%s', group)
                            
    1              0.000002             let b:mkd_known_filetypes[ft] = 1
    1              0.000000         endif
    2              0.000003     endfor

FUNCTION  <SNR>80_stopline_back()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:482
Called 34 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
   34              0.000079   let stopline_back = line('.') - g:context_filetype#search_offset
   34              0.000057   return (stopline_back <= 1) ? 1 : stopline_back

FUNCTION  denite#util#input()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/util.vim:203
Called 1 time
Total time:   0.001104
 Self time:   0.001104

count  total (s)   self (s)
    1              0.000010   let text = get(a:000, 0, '')
    1              0.000002   let completion = get(a:000, 1, '')
    1              0.000001   try
    1              0.000002     if completion !=# ''
                                  return input(a:prompt, text, completion)
    1              0.000001     else
    1              0.001076       return input(a:prompt, text)
                                endif
                              catch
                                " ignore the errors
                                return ''
    1              0.000001   endtry

FUNCTION  prettier#resolver#executable#getPath()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/executable.vim:9
Called 1 time
Total time:   0.000411
 Self time:   0.000220

count  total (s)   self (s)
    1              0.000037   let l:user_defined_exec_path = fnamemodify(g:prettier#exec_cmd_path, ':p')
    1              0.000007   if executable(l:user_defined_exec_path)
                                return l:user_defined_exec_path
    1              0.000001   endif
                            
    1   0.000193   0.000025   let l:localExec = s:ResolveExecutable(getcwd())
    1              0.000066   if executable(l:localExec)
                                return fnameescape(l:localExec)
    1              0.000000   endif
                            
    1   0.000031   0.000007   let l:globalExec = s:ResolveExecutable()
    1              0.000069   if executable(l:globalExec)
    1              0.000003     return fnameescape(l:globalExec)
                              endif
                            
                              let l:pluginExec = s:ResolveExecutable(s:ROOT_DIR)
                              if executable(l:pluginExec)
                                return fnameescape(l:pluginExec)
                              endif
                            
                              return -1

FUNCTION  <SNR>105_substitute_path_separator()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/neomru.vim:16
Called 35 times
Total time:   0.000159
 Self time:   0.000159

count  total (s)   self (s)
   35              0.000134   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  context_filetype#filetypes()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:93
Called 38 times
Total time:   0.002368
 Self time:   0.002368

count  total (s)   self (s)
   38              0.000087   if exists('b:context_filetype_filetypes')
                                return deepcopy(b:context_filetype_filetypes)
   38              0.000020   endif
   38              0.002167   return extend(deepcopy(s:default_filetypes), deepcopy(g:context_filetype#filetypes))

FUNCTION  indent_guides#process_autocmds()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/indent_guides.vim:21
Called 11 times
Total time:   0.027503
 Self time:   0.000124

count  total (s)   self (s)
   11              0.000018   if g:indent_guides_autocmds_enabled
   11   0.027446   0.000067     call indent_guides#enable()
                              else
                                call indent_guides#disable()
   11              0.000004   end

FUNCTION  <SNR>83_line()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lightline.vim:401
Called 13 times
Total time:   0.012090
 Self time:   0.004709

count  total (s)   self (s)
   13              0.000025   let _ = a:tabline ? '' : '%{lightline#link()}'
   13              0.000020   if s:lightline.palette == {}
                                call lightline#colorscheme()
   13              0.000005   endif
   13              0.000044   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
   13              0.000041   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
   13              0.000047   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
   13              0.000022   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
   13              0.000047   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
   13   0.003145   0.000190   let [lt, lc, ll] = s:expand(copy(l_))
   13              0.000052   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
   13   0.002644   0.000160   let [rt, rc, rl] = s:expand(copy(r_))
   34              0.000045   for i in range(len(lt))
   21              0.000070     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
   74              0.000083     for j in range(len(lt[i]))
   53              0.000373       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
   53              0.000315       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
   53              0.000102       if j < len(lt[i]) - 1 && s.left !=# ''
   32   0.001806   0.000385         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
   53              0.000024       endif
   74              0.000028     endfor
   21              0.000082     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
   21              0.000107     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
   34              0.000027   endfor
   13              0.000058   let _ .= '%#LightlineMiddle_' . mode . '#%='
   39              0.000051   for i in range(len(rt) - 1, 0, -1)
   26              0.000098     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
   26              0.000116     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
   26              0.000070     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
   68              0.000080     for j in range(len(rt[i]))
   42              0.000251       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
   42              0.000230       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
   42              0.000073       if j < len(rt[i]) - 1 && s.right !=# ''
   16   0.000708   0.000187         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
   42              0.000018       endif
   68              0.000028     endfor
   39              0.000026   endfor
   13              0.000011   return _

FUNCTION  <SNR>98_on_text_changed_after()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/ui/vim/signature_help.vim:121
Called 6 times
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
    6              0.000069     if bufnr('%') != a:bufnr
                                    return
    6              0.000006     endif
    6              0.000033     if index(['i', 's'], mode()[0]) == -1
    6              0.000005         return
                                endif
                                if win_id2win(lsp#ui#vim#output#getpreviewwinid()) >= 1
                                    return
                                endif
                            
                                " Cache trigger chars since this loop is heavy
                                let l:chars = get(b:, 'lsp_signature_help_trigger_character', [])
                                if empty(l:chars)
                                    for l:server_name in lsp#get_whitelisted_servers(a:bufnr)
                                        let l:chars += lsp#capabilities#get_signature_help_trigger_characters(l:server_name)
                                    endfor
                                    let b:lsp_signature_help_trigger_character = l:chars
                                endif
                            
                                if index(l:chars, lsp#utils#_get_before_char_skip_white()) >= 0
                                    call lsp#ui#vim#signature_help#get_signature_help_under_cursor()
                                endif

FUNCTION  <SNR>154_parse_options()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/helper.vim:134
Called 1 time
Total time:   0.000847
 Self time:   0.000351

count  total (s)   self (s)
    1              0.000001   let args = []
    1              0.000001   let options = {}
                            
                              " Eval
    1              0.000010   let cmdline = (a:cmdline =~# '\\\@<!`.*\\\@<!`') ? s:eval_cmdline(a:cmdline) : a:cmdline
                            
    2   0.000036   0.000028   for s in split(cmdline, s:re_unquoted_match('\%(\\\@<!\s\)\+'))
    1              0.000005     let arg = substitute(s, '\\\( \)', '\1', 'g')
    1              0.000005     let arg_key = substitute(arg, '=\zs.*$', '', '')
                            
    1              0.000006     let name = substitute(tr(arg_key, '-', '_'), '=$', '', '')[1:]
    1              0.000003     if name =~# '^no_'
                                  let name = name[3:]
                                  let value = v:false
    1              0.000001     else
    1              0.000005       let value = (arg_key =~# '=$') ? s:remove_quote_pairs(arg[len(arg_key) :]) : v:true
    1              0.000001     endif
                            
    1   0.000735   0.000248     if index(keys(denite#init#_user_options()) + keys(denite#init#_deprecated_options()), name) >= 0
                                  let options[name] = value
    1              0.000001     else
    1              0.000003       call add(args, arg)
    1              0.000001     endif
    2              0.000003   endfor
                            
    1              0.000002   return [args, options]

FUNCTION  <SNR>155_initialize_variables()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite/init.vim:81
Called 1 time
Total time:   0.000024
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000002   let g:denite#_filter_winid = -1
    1              0.000003   let g:denite#_previewed_buffers = {}
    1              0.000002   let g:denite#_candidates = []
    1              0.000001   let g:denite#_ret = {}
    1              0.000001   let g:denite#_async_ret = {}
    1              0.000001   let g:denite#_filter_bufnr = -1
    1   0.000009   0.000007   let g:denite#_serveraddr = denite#util#has_yarp() ? neovim_rpc#serveraddr() : v:servername
    1              0.000001   if g:denite#_serveraddr ==# ''
                                " Use NVIM_LISTEN_ADDRESS
                                let g:denite#_serveraddr = $NVIM_LISTEN_ADDRESS
    1              0.000000   endif

FUNCTION  <SNR>162_Flag_tab_width()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/config.vim:50
Called 1 time
Total time:   0.000810
 Self time:   0.000197

count  total (s)   self (s)
    1              0.000003   let l:value = get(a:config, 'tabWidth', g:prettier#config#tab_width)
                            
    1              0.000001   if (l:value ==# 'auto')
    1   0.000801   0.000189     let l:value = prettier#utils#shim#shiftwidth()
    1              0.000001   endif
                            
    1              0.000002   return '--tab-width=' . l:value

FUNCTION  prettier#Prettier()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier.vim:51
Called 1 time
Total time:   0.007224
 Self time:   0.001018

count  total (s)   self (s)
    1   0.001365   0.000190   let l:execCmd = prettier#resolver#executable#getPath()
    1              0.000002   let l:async = a:0 > 0 ? a:1 : 0
    1              0.000001   let l:startSelection = a:0 > 1 ? a:2 : 1
    1              0.000002   let l:endSelection = a:0 > 2 ? a:3 : line('$')
    1              0.000001   let l:hasSelection = a:0 > 2 ? 1 : 0
    1              0.000002   let l:partialFormat = a:0 > 3 && a:4 ? a:4 : 0
    1              0.000002   let l:partialFormatEnabled = l:hasSelection && l:partialFormat
                            
    1              0.000001   let l:overWrite = a:0 > 4 ? a:5 : {}
    1              0.000005   let l:bufferConfig = getbufvar(bufnr('%'), 'prettier_ft_default_args', {})
    1              0.000003   let l:config = extend(l:bufferConfig, l:overWrite)
                            
    1              0.000001   if l:execCmd != -1
                                " TODO
                                " => we should make sure we can resolve --range-start  and --range-end when required
                                "    => when the above is required we should also update l:startSelection to '1' and l:endSelection to line('$')
    1   0.002349   0.000417     let l:cmd = l:execCmd . prettier#resolver#config#resolve( prettier#resolver#preset#resolve(l:config), l:partialFormatEnabled, l:startSelection,  l:endSelection)
                            
                                " close quickfix if it is opened
    1   0.000699   0.000179     call prettier#utils#quickfix#close()
                            
                                " we will be using portion formatting, so we need to send entire buffer to prettier
    1              0.000001     if l:partialFormatEnabled
                                  let l:startSelection = 1
                                  let l:endSelection = line('$')
    1              0.000000     endif
                            
                                " format buffer
    1   0.002776   0.000196     call prettier#job#runner#run(l:cmd, l:startSelection, l:endSelection, l:async)
                              else
                                call prettier#logging#error#log('EXECUTABLE_NOT_FOUND_ERROR')
    1              0.000000   endif

FUNCTION  <SNR>78_stop_region_update()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/precious/switcher/outer_region.vim:38
Called 1 time
Total time:   0.000191
 Self time:   0.000182

count  total (s)   self (s)
    1              0.000001   augroup precious-switcher-outer-region
    1              0.000174     autocmd! * <buffer>
    1              0.000001   augroup END
    1   0.000014   0.000005   call s:clear_region()

FUNCTION  remote#define#FunctionBootstrap()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/autoload/remote/define.vim:145
Called 1 time
Total time:   0.000216
 Self time:   0.000145

count  total (s)   self (s)
    1   0.000022   0.000007   let channel = remote#host#Require(a:host)
                            
    1              0.000067   exe 'autocmd! '.a:group
    1              0.000041   exe 'augroup! '.a:group
    1              0.000001   if channel
    1   0.000081   0.000025     call remote#define#FunctionOnChannel(channel, a:method, a:sync, a:name, a:opts)
                              else
                                echoerr 'Host "'a:host.'" for "'.a:name.'" function is not available'
    1              0.000000   endif

FUNCTION  <SNR>158_not_supported()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/lsp/ui/vim.vim:1
Called 1 time
Total time:   0.000054
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000053   0.000007     return lsp#utils#error(a:what.' not supported for '.&filetype)

FUNCTION  <SNR>68_AddEval()
    Defined: /usr/local/Cellar/neovim/HEAD-251b20e/share/nvim/runtime/autoload/remote/define.vim:274
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000001   if has_key(a:opts, 'eval')
                                if type(a:opts.eval) != type('') || a:opts.eval == ''
                                  throw "Eval option must be a non-empty string"
                                endif
                                " evaluate an expression and pass as argument
                                call add(a:rpcargs, 'eval("'.escape(a:opts.eval, '"').'")')
    1              0.000000   endif

FUNCTION  <SNR>162_Flag_parser()
    Defined: ~/.cache/dein/repos/github.com/prettier/vim-prettier/autoload/prettier/resolver/config.vim:90
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003   let l:value = get(a:config, 'parser', g:prettier#config#parser)
                            
    1              0.000001   if (l:value !=# '')
    1              0.000001     return '--parser=' . l:value
                              else
                                return ''
                              endif

FUNCTION  context_filetype#get_filetype()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/context_filetype.vim:37
Called 38 times
Total time:   0.014427
 Self time:   0.002277

count  total (s)   self (s)
   38              0.000134   let base_filetype = get(a:, 1, &filetype)
   38   0.014271   0.002121   return context_filetype#get(base_filetype).filetype

FUNCTION  <SNR>85_FileIgnoreCase()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:120
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000007   return (exists('+fileignorecase') && &fileignorecase) || (a:for_completion && exists('+wildignorecase') && &wildignorecase)

FUNCTION  <SNR>85_Dir()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/fugitive.vim:275
Called 577 times
Total time:   0.011483
 Self time:   0.003591

count  total (s)   self (s)
  577   0.011282   0.003391   return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()

FUNCTION  <SNR>55_is_enable_switch_CursorHold()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/plugin/precious.vim:34
Called 1 time
Total time:   0.000047
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000047   0.000010 	return precious#switch_def(g:precious_enable_switch_CursorHold, a:filetype, 1)

FUNCTION  denite#do_map()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite.vim:45
Called 1 time
Total time:   0.000036
 Self time:   0.000031

count  total (s)   self (s)
    1   0.000023   0.000017   let args = denite#util#convert2list(get(a:000, 0, []))
    1              0.000003   let esc = (mode() ==# 'i' ? "\<C-o>" : '')
    1              0.000009   return printf(esc . ":\<C-u>call denite#_call_map(%s, %s, %s)\<CR>", string(a:name), 'v:false', string(args))

FUNCTION  denite#_call_map()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite.vim:51
Called 2 times
Total time:   0.014467
 Self time:   0.000093

count  total (s)   self (s)
    2              0.000008   let is_filter = &l:filetype ==# 'denite-filter'
                            
    2              0.000002   if is_filter
                                call denite#filter#_move_to_parent(v:true)
    2              0.000002   endif
                            
    2              0.000003   if &l:filetype !=# 'denite'
                                return
    2              0.000001   endif
                            
    2   0.000022   0.000014   let args = denite#util#convert2list(a:args)
                            
    2   0.014407   0.000041   call denite#util#rpcrequest( (a:is_async ? '_denite_do_async_map' : '_denite_do_map'), [bufnr('%'), a:name, args], a:is_async)
                            
    2              0.000002   if is_filter
                                call s:update_filter()
    2              0.000001   endif

FUNCTION  color_helper#hex_color_to_rgb()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/color_helper.vim:39
Called 22 times
Total time:   0.000989
 Self time:   0.000724

count  total (s)   self (s)
   22              0.000023   let l:rgb = []
                            
   22              0.000095   if a:hex_color =~ g:indent_guides_color_hex_pattern
   22   0.000329   0.000211     let l:red   = color_helper#hex_to_dec(strpart(a:hex_color, 1, 2))
   22   0.000195   0.000127     let l:green = color_helper#hex_to_dec(strpart(a:hex_color, 3, 2))
   22   0.000241   0.000162     let l:blue  = color_helper#hex_to_dec(strpart(a:hex_color, 5, 2))
   22              0.000040     let l:rgb = [l:red, l:green, l:blue]
   22              0.000010   end
                            
   22              0.000014   return l:rgb

FUNCTION  denite#call_async_map()
    Defined: ~/.cache/dein/.cache/init.vim/.dein/autoload/denite.vim:101
Called 1 time
Total time:   0.000100
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000099   0.000012   call denite#_call_map(a:name, v:true, get(a:000, 0, []))

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    4   0.155283   0.103032  denite#util#rpcrequest()
    1   0.142292   0.000258  denite#helper#call_denite()
    1   0.140807   0.000038  denite#start()
    1   0.140769   0.000025  <SNR>156_start()
    4   0.137051   0.001492  33()
  288   0.111623   0.003970  fugitive#head()
    3   0.104895   0.012940  38()
  288   0.101581   0.017174  fugitive#Head()
 1861   0.092515             <SNR>105_is_file_exist()
    8   0.091788   0.000165  <SNR>53_append()
    8   0.091622   0.000225  neomru#_append()
    7   0.090640   0.001522  neomru#append()
   12   0.087729   0.000182  36()
  288   0.079030   0.052133  fugitive#Find()
    1   0.049894   0.000042  neomru#_save()
   11   0.027503   0.000124  indent_guides#process_autocmds()
   11   0.027380   0.013551  indent_guides#enable()
    4   0.027344   0.000329  <SNR>105_uniq()
    4   0.027015             <SNR>105_uniq_by()
  865   0.016536   0.015286  FugitiveGitDir()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    4   0.155283   0.103032  denite#util#rpcrequest()
 1861              0.092515  <SNR>105_is_file_exist()
  288   0.079030   0.052133  fugitive#Find()
    4              0.027015  <SNR>105_uniq_by()
  288   0.101581   0.017174  fugitive#Head()
  865   0.016536   0.015286  FugitiveGitDir()
   11   0.027380   0.013551  indent_guides#enable()
    3   0.104895   0.012940  38()
  288              0.005476  fugitive#CommonDir()
   99              0.005214  LightlineFilename()
  638              0.004954  indent_guides#indent_highlight_pattern()
   13   0.012090   0.004709  <SNR>83_line()
   99              0.004461  lightline#link()
   20   0.005215   0.004025  dein#autoload#_on_default_event()
    3   0.003981   0.003980  <SNR>27_ftplugin()
  288   0.111623   0.003970  fugitive#head()
   26   0.005439   0.003832  <SNR>83_expand()
   76   0.007208   0.003815  <SNR>80_get_context()
  864              0.003788  <SNR>85_Slash()
   11   0.003748   0.003704  indent_guides#clear_matches()

